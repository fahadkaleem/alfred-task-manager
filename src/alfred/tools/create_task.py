"""
Create Task Tool - Standardized task creation within Alfred
"""

import os
import json
from pathlib import Path
from typing import Dict, Any
from alfred.lib.structured_logger import get_logger
from alfred.lib.md_parser import MarkdownTaskParser
from alfred.models.schemas import ToolResponse
from alfred.config.settings import settings

logger = get_logger(__name__)

TASK_TEMPLATE = """## Title
Example task demonstrating the correct format

## Context
This is a sample task file that demonstrates the correct markdown format expected by Alfred. It shows all required and optional sections that can be used when creating tasks.

## Implementation Details
Create a well-formatted markdown file that follows the exact structure expected by the MarkdownTaskParser. The file should include all required sections and demonstrate optional sections as well.

## Acceptance Criteria
- Must include Title, Context, Implementation Details, and Acceptance Criteria sections
- Should follow the exact section headers expected by the parser
- Must be parseable by the MarkdownTaskParser without errors

## AC Verification
- Verify that the md_parser can successfully parse the file
- Confirm all required fields are extracted correctly
- Test that the Task pydantic model can be created from parsed data
- Ensure no validation errors occur during task loading

## Dev Notes
This file serves as both documentation and a working example. Task IDs are now automatically generated by Alfred in the format TK-XX."""


# New logic function for GenericWorkflowHandler
def create_task_logic(task_content: str, **kwargs) -> ToolResponse:
    """Logic function for create_task compatible with GenericWorkflowHandler."""
    try:
        # Generate the next task ID
        task_id = generate_next_task_id()

        # Prepend the task ID to the content
        full_task_content = f"# TASK: {task_id}\n\n{task_content.strip()}"

        # Initialize parser
        parser = MarkdownTaskParser()

        # Validate format of the full content
        is_valid, error_msg = parser.validate_format(full_task_content)
        if not is_valid:
            # If validation fails, we need to decrement the counter
            # This is a bit hacky but necessary to maintain consistency
            tasks_dir = Path(settings.alfred_dir) / "tasks"
            counter_file = tasks_dir / "task_counter.json"
            if counter_file.exists():
                with open(counter_file, "r") as f:
                    counter_data = json.load(f)
                counter_data["last_task_number"] -= 1
                with open(counter_file, "w") as f:
                    json.dump(counter_data, f, indent=2)

            return ToolResponse(
                status="error",
                message="Task content format is invalid.",
                data={
                    "validation_error": error_msg,
                    "template": TASK_TEMPLATE,
                    "help": "Your task content must follow the exact template format shown above. Key requirements:\n"
                    "1. Must include sections: Title, Context, Implementation Details, Acceptance Criteria\n"
                    "2. Sections must use '##' headers\n"
                    "3. Content cannot be empty\n"
                    "Note: Task IDs are now automatically generated!",
                },
            )

        # Parse to validate structure
        try:
            parsed_data = parser.parse(full_task_content)
        except Exception as e:
            # Decrement counter on failure
            tasks_dir = Path(settings.alfred_dir) / "tasks"
            counter_file = tasks_dir / "task_counter.json"
            if counter_file.exists():
                with open(counter_file, "r") as f:
                    counter_data = json.load(f)
                counter_data["last_task_number"] -= 1
                with open(counter_file, "w") as f:
                    json.dump(counter_data, f, indent=2)

            return ToolResponse(
                status="error", message="Failed to parse task content.", data={"parse_error": str(e), "template": TASK_TEMPLATE, "help": "Ensure your task content follows the exact template format."}
            )

        # Ensure .alfred/tasks directory exists
        tasks_dir = Path(settings.alfred_dir) / "tasks"
        tasks_dir.mkdir(parents=True, exist_ok=True)

        # Create task file path
        task_file_path = tasks_dir / f"{task_id}.md"

        # Write the task file with the full content including task ID
        task_file_path.write_text(full_task_content, encoding="utf-8")

        logger.info(f"Created new task file: {task_file_path}")

        return ToolResponse(
            status="success",
            message=f"Task '{task_id}' created successfully.",
            data={
                "task_id": task_id,
                "file_path": str(task_file_path),
                "task_title": parsed_data.get("title", ""),
                "next_action": f"Use work_on_task('{task_id}') to start working on this task.",
                "note": "Task ID was automatically generated.",
            },
        )

    except Exception as e:
        logger.error(f"Error creating task: {e}")
        # Decrement counter on any failure
        try:
            tasks_dir = Path(settings.alfred_dir) / "tasks"
            counter_file = tasks_dir / "task_counter.json"
            if counter_file.exists():
                with open(counter_file, "r") as f:
                    counter_data = json.load(f)
                counter_data["last_task_number"] -= 1
                with open(counter_file, "w") as f:
                    json.dump(counter_data, f, indent=2)
        except Exception as counter_err:
            logger.error(f"Failed to decrement counter: {counter_err}")

        return ToolResponse(
            status="error",
            message="An unexpected error occurred while creating the task.",
            data={"error": str(e), "template": TASK_TEMPLATE, "help": "Please check the task content format and try again."},
        )


def generate_next_task_id() -> str:
    """
    Generates the next task ID by reading and incrementing the counter in task_counter.json

    Returns:
        str: The next task ID in format TK-XX
    """
    tasks_dir = Path(settings.alfred_dir) / "tasks"
    counter_file = tasks_dir / "task_counter.json"

    # Ensure directory exists
    tasks_dir.mkdir(parents=True, exist_ok=True)

    # Read current counter or initialize
    if counter_file.exists():
        with open(counter_file, "r") as f:
            counter_data = json.load(f)
    else:
        counter_data = {"last_task_number": 0, "prefix": "TS", "created_at": "2025-07-04", "description": "Tracks the last assigned task number for auto-incrementing task IDs"}

    # Increment counter
    counter_data["last_task_number"] += 1
    next_number = counter_data["last_task_number"]

    # Save updated counter
    with open(counter_file, "w") as f:
        json.dump(counter_data, f, indent=2)

    # Generate task ID with zero-padding
    task_id = f"{counter_data['prefix']}-{next_number:02d}"

    logger.info(f"Generated new task ID: {task_id}")
    return task_id


# Legacy create_task_impl function removed - now using create_task_logic with GenericWorkflowHandler
