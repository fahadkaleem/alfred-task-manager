### **TASK: AL-02 (Revised)**

#### **Title:**
Architectural Foundation: Implement `BaseWorkflowTool` and `PlanTaskTool` State Machine

#### **Context:**
With our core data models now defined and validated, we will build the skeleton for our tool-based architecture. This involves creating a `BaseWorkflowTool` to house common logic and defining the specific State Machine (SM) for our first and most critical tool, `plan_task`. This SM will manage the internal lifecycle of the planning process, from initial context gathering to the final verification of the `ExecutionPlan`.

#### **Implementation Details:**
1.  **Create `BaseWorkflowTool` class.** This base class will establish the common interface for all workflow tools. It will contain the reusable, pre-built logic for handling the standard two-step (AI, Human) review cycle.
2.  **Create `PlanTaskTool` class inheriting from `BaseWorkflowTool`.**
3.  **Define the `PlanTaskTool` State Machine.** Inside this class, define the states and transitions using the `transitions` library. We will use the clean, single-verb state names we agreed upon (`contextualize`, `strategize`, `design`, `generate_slots`).

**Dev Notes:**
*   This task focuses purely on the SM structure. No prompt generation or execution logic is to be implemented yet.
*   The SM states must be defined as an Enum to prevent magic strings, upholding our new standard.
*   The `_create_review_transitions` helper in the base class is a critical pattern for code reuse. It will take a `source_state` and a `success_destination_state` as arguments.

**Files to Modify:**

1.  **`src/alfred_new/core/workflow.py` (NEW FILE):**
    ```python
    # src/alfred_new/core/workflow.py
    from transitions.core import Machine
    from typing import List, Dict, Any
    from enum import Enum

    class PlanTaskState(str, Enum):
        """States for the PlanTaskTool's internal State Machine."""
        CONTEXTUALIZE = "contextualize"
        REVIEW_CONTEXT = "review_context"
        STRATEGIZE = "strategize"
        REVIEW_STRATEGY = "review_strategy"
        DESIGN = "design"
        REVIEW_DESIGN = "review_design"
        GENERATE_SLOTS = "generate_slots"
        REVIEW_PLAN = "review_plan"
        VERIFIED = "verified" # The final, terminal state for the tool.

    class BaseWorkflowTool:
        """A base class providing shared State Machine logic for Alfred's tools."""
        def __init__(self, task_id: str):
            self.task_id = task_id
            self.state = None # Will be set by the Machine instance
            self.machine = None

        def _create_review_transitions(self, source_state: Enum, success_destination_state: Enum) -> List[Dict[str, Any]]:
            """Factory for creating the standard two-step (AI, Human) review transitions."""
            review_state = f"review_{source_state.value}"
            
            return [
                # Submit work, transition into the review state for AI self-review
                {'trigger': f'submit_{source_state.value}', 'source': source_state, 'dest': review_state},
                # AI self-approves, moves to human review
                {'trigger': 'ai_approve', 'source': review_state, 'dest': success_destination_state},
                # A rejection from AI review goes back to the source state to be reworked
                {'trigger': 'request_revision', 'source': review_state, 'dest': source_state},
            ]

    class PlanTaskTool(BaseWorkflowTool):
        """Encapsulates the state and logic for the `plan_task` command."""
        def __init__(self, task_id: str):
            super().__init__(task_id)
            
            # Use the PlanTaskState Enum for state definitions
            states = list(PlanTaskState)

            transitions = [
                *self._create_review_transitions(PlanTaskState.CONTEXTUALIZE, PlanTaskState.STRATEGIZE),
                *self._create_review_transitions(PlanTaskState.STRATEGIZE, PlanTaskState.DESIGN),
                *self._create_review_transitions(PlanTaskState.DESIGN, PlanTaskState.GENERATE_SLOTS),
                *self._create_review_transitions(PlanTaskState.GENERATE_SLOTS, PlanTaskState.VERIFIED),
            ]
            
            self.machine = Machine(model=self, states=states, transitions=transitions, initial=PlanTaskState.CONTEXTUALIZE)
    ```

#### **Acceptance Criteria:**
*   The `src/alfred_new/core/workflow.py` file is created.
*   It contains the `BaseWorkflowTool` and `PlanTaskTool` classes.
*   A `PlanTaskState` Enum is defined and used for the state machine states.
*   The `PlanTaskTool` constructor correctly initializes a `Machine` instance with all specified states and transitions.
*   The `_create_review_transitions` helper method is implemented and used correctly.

#### **AC Verification:**
*   Instantiate `PlanTaskTool(task_id="TS-01")`.
*   Assert `tool.state == PlanTaskState.CONTEXTUALIZE`.
*   Call `tool.submit_contextualize()`. Assert `tool.state == PlanTaskState.REVIEW_CONTEXT`.
*   Call `tool.request_revision()`. Assert `tool.state == PlanTaskState.CONTEXTUALIZE`.
*   Call `tool.submit_contextualize()` again, then `tool.ai_approve()`. Assert `tool.state == PlanTaskState.STRATEGIZE`.
*   Continue this pattern to verify the full flow.

#### **Unit Tests:**
*   Create a new test file `tests/core/test_plan_task_sm.py`.
*   Write a test `test_initial_state` to confirm the tool starts in `CONTEXTUALIZE`.
*   Write a test `test_full_success_flow` that triggers the success path through all states to `VERIFIED`.
*   Write a test `test_rejection_at_design_review` that simulates a `request_revision` call from the `REVIEW_DESIGN` state and confirms the tool transitions back to `DESIGN`.