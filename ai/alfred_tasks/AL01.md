### **Implementation Directive: AL-01 - Unify State Management**

**Objective:** Eradicate the fragmented state model. We will unify `state.json` and `tool_state.json` into a single, atomic `task_state.json`. This is the foundational fix for system stability.

**Executor's Action:** You will instruct the agent to replace the entire contents of the specified files with the code blocks provided below. No merging. No modification. A direct replacement.

#### **1. Replace `src/alfred/models/state.py`:**
This establishes the new unified schema.

```python
# src/alfred/models/state.py
"""
Pydantic models for Alfred's state management.
This module defines the single source of truth for task state.
"""
from datetime import datetime
from typing import Dict, Any, Optional

from pydantic import BaseModel, Field

from src.alfred/models.schemas import TaskStatus


class WorkflowState(BaseModel):
    """
    Represents the complete state of a workflow tool.
    This model captures all necessary information to reconstruct
    a workflow tool after a crash or restart.
    """

    task_id: str
    tool_name: str
    current_state: str  # String representation of the state enum
    context_store: Dict[str, Any] = Field(default_factory=dict)
    persona_name: str
    created_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())
    updated_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())


class UnifiedTaskState(BaseModel):
    """
    The single, unified state object for a task.
    This is the schema for the new `task_state.json` file.
    """

    task_id: str
    task_status: TaskStatus = Field(default=TaskStatus.NEW)
    active_tool_state: Optional[WorkflowState] = Field(default=None)
    updated_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())

```

#### **2. Replace `src/alfred/state/manager.py`:**
This implements the new, unified state management logic.

```python
# src/alfred/state/manager.py
"""
Unified state management for Alfred.
Provides atomic state persistence for the UnifiedTaskState object.
"""
import json
from datetime import datetime
from pathlib import Path
from typing import Optional

from pydantic import BaseModel

from src.alfred.config.settings import settings
from src.alfred.constants import Paths
from src.alfred.lib.logger import get_logger
from src.alfred.models.schemas import TaskStatus
from src.alfred.models.state import UnifiedTaskState, WorkflowState

logger = get_logger(__name__)


class StateManager:
    """Manages the persistent state for a single task via task_state.json."""

    def _get_task_state_file(self, task_id: str) -> Path:
        """Gets the path to the unified state file for a task."""
        return settings.workspace_dir / task_id / "task_state.json"

    def load_or_create_task_state(self, task_id: str) -> UnifiedTaskState:
        """Loads a task's unified state from disk, or creates it if it doesn't exist."""
        state_file = self._get_task_state_file(task_id)
        if not state_file.exists():
            logger.info(f"No state file found for task {task_id}. Creating new state.")
            new_state = UnifiedTaskState(task_id=task_id)
            self.save_task_state(new_state)
            return new_state

        try:
            state_json = state_file.read_text()
            state_data = UnifiedTaskState.model_validate_json(state_json)
            tool_name = (
                state_data.active_tool_state.tool_name
                if state_data.active_tool_state
                else "None"
            )
            logger.info(
                f"Loaded state for task {task_id}. Status: {state_data.task_status.value}, Active Tool: {tool_name}."
            )
            return state_data
        except Exception as e:
            logger.error(
                f"Failed to load or validate state for task {task_id}, creating new state. Error: {e}"
            )
            new_state = UnifiedTaskState(task_id=task_id)
            self.save_task_state(new_state)
            return new_state

    def save_task_state(self, state: UnifiedTaskState) -> None:
        """Atomically saves the entire unified state for a task."""
        state.updated_at = datetime.utcnow().isoformat()
        state_file = self._get_task_state_file(state.task_id)
        state_file.parent.mkdir(parents=True, exist_ok=True)

        temp_file = state_file.with_suffix(Paths.JSON_EXTENSION + Paths.TMP_EXTENSION)
        try:
            temp_file.write_text(state.model_dump_json(indent=2))
            temp_file.replace(state_file)
            logger.info(f"Successfully saved state for task {state.task_id}.")
        except Exception as e:
            logger.error(f"Failed to save state for task {state.task_id}: {e}")
            if temp_file.exists():
                temp_file.unlink()
            raise

    def update_task_status(self, task_id: str, new_status: TaskStatus) -> UnifiedTaskState:
        """Loads, updates the task_status, and saves the state."""
        state = self.load_or_create_task_state(task_id)
        state.task_status = new_status
        self.save_task_state(state)
        logger.info(f"Updated task {task_id} status to {new_status.value}")
        return state

    def update_tool_state(
        self, task_id: str, tool: "BaseWorkflowTool"
    ) -> UnifiedTaskState:
        """Loads, updates the tool state portion, and saves."""
        state = self.load_or_create_task_state(task_id)

        serializable_context = {}
        if tool.context_store:
            for key, value in tool.context_store.items():
                if isinstance(value, BaseModel):
                    serializable_context[key] = value.model_dump()
                else:
                    serializable_context[key] = value

        tool_state_data = WorkflowState(
            task_id=task_id,
            tool_name=tool.tool_name,
            current_state=str(tool.state),
            context_store=serializable_context,
            persona_name=tool.persona_name,
            updated_at=datetime.utcnow().isoformat(),
        )
        state.active_tool_state = tool_state_data
        self.save_task_state(state)
        return state

    def clear_tool_state(self, task_id: str) -> UnifiedTaskState:
        """Loads, clears the active tool state, and saves."""
        state = self.load_or_create_task_state(task_id)
        if state.active_tool_state:
            logger.info(f"Clearing active tool state for task {task_id}.")
            state.active_tool_state = None
            self.save_task_state(state)
        return state


# Singleton instance
state_manager = StateManager()
```

#### **3. Replace `src/alfred/state/recovery.py`:**
This adapts the recovery mechanism to the new unified state model.

```python
# src/alfred/state/recovery.py
"""
Tool recovery functionality for Alfred workflow tools.
Handles reconstruction of workflow tools from persisted state.
"""
from typing import Dict, Optional, Type

from src.alfred.core.workflow import BaseWorkflowTool, PlanTaskTool
from src.alfred.lib.logger import get_logger
from src.alfred.state.manager import state_manager
from src.alfred.constants import ToolName

logger = get_logger(__name__)


class ToolRecovery:
    """Handles recovery of workflow tools from persisted state."""

    TOOL_REGISTRY: Dict[str, Type[BaseWorkflowTool]] = {
        ToolName.PLAN_TASK: PlanTaskTool,
    }

    @classmethod
    def recover_tool(cls, task_id: str) -> Optional[BaseWorkflowTool]:
        """Attempt to recover a tool from the unified persisted state."""
        task_state = state_manager.load_or_create_task_state(task_id)
        persisted_tool_state = task_state.active_tool_state

        if not persisted_tool_state:
            logger.debug(f"No active tool state found for task {task_id} to recover.")
            return None

        tool_name = persisted_tool_state.tool_name
        tool_class = cls.TOOL_REGISTRY.get(tool_name)
        if not tool_class:
            logger.error(f"Unknown tool type: {tool_name}. Cannot recover.")
            return None

        try:
            tool = tool_class(task_id=task_id)
            tool.state = persisted_tool_state.current_state
            tool.context_store = persisted_tool_state.context_store
            tool.persona_name = persisted_tool_state.persona_name

            logger.info(
                f"Successfully recovered {tool_name} for task {task_id} in state {tool.state}"
            )
            return tool
        except Exception as e:
            logger.error(
                f"Failed to recover tool for task {task_id}: {e}", exc_info=True
            )
            return None

    @classmethod
    def register_tool(cls, tool_name: str, tool_class: Type[BaseWorkflowTool]) -> None:
        """Register a new tool type for recovery."""
        cls.TOOL_REGISTRY[tool_name] = tool_class
        logger.debug(f"Registered tool type: {tool_name}")

    @classmethod
    def can_recover(cls, task_id: str) -> bool:
        """Check if a task has a recoverable tool state."""
        task_state = state_manager.load_or_create_task_state(task_id)
        persisted_tool_state = task_state.active_tool_state
        if not persisted_tool_state:
            return False

        tool_name = persisted_tool_state.tool_name
        return tool_name in cls.TOOL_REGISTRY
```

#### **4. Replace `src/alfred/lib/task_utils.py`:**
This removes the old, fragmented state logic and relies on the new `StateManager`.

```python
# src/alfred/lib/task_utils.py
from pathlib import Path
from typing import Optional

from src.alfred.models.schemas import Task
from src.alfred.state.manager import state_manager

from .md_parser import MarkdownTaskParser
from src.alfred.config.settings import settings


def load_task(task_id: str, root_dir: Optional[Path] = None) -> Task | None:
    """
    Loads a Task by parsing its .md file and merging with its unified state.

    Args:
        task_id: The ID of the task to load
        root_dir: Optional root directory to use instead of default settings
    """
    alfred_dir = (
        root_dir / settings.alfred_dir_name if root_dir else settings.alfred_dir
    )
    task_md_path = alfred_dir / "tasks" / f"{task_id}.md"

    if not task_md_path.exists():
        return None

    parser = MarkdownTaskParser()
    task_data = parser.parse(task_md_path.read_text())
    task_model = Task(**task_data)

    # Load the dynamic state from the unified state file
    unified_state = state_manager.load_or_create_task_state(task_id)
    task_model.task_status = unified_state.task_status

    return task_model
```

#### **5. Replace `src/alfred/tools/plan_task.py`:**
This updates the tool controller to use the new unified state mechanism.

```python
# src/alfred/tools/plan_task.py
import json

from src.alfred.core.prompter import prompter
from src.alfred.core.workflow import PlanTaskState, PlanTaskTool
from src.alfred.lib.logger import get_logger, setup_task_logging
from src.alfred.lib.task_utils import load_task
from src.alfred.models.schemas import TaskStatus, ToolResponse
from src.alfred.orchestration.orchestrator import orchestrator
from src.alfred.orchestration.persona_loader import load_persona
from src.alfred.state.manager import state_manager
from src.alfred.state.recovery import ToolRecovery

logger = get_logger(__name__)


async def plan_task_impl(task_id: str) -> ToolResponse:
    """Implementation logic for the plan_task tool with unified state."""
    setup_task_logging(task_id)

    task = load_task(task_id)
    if not task:
        return ToolResponse(status="error", message=f"Task '{task_id}' not found.")

    if task_id in orchestrator.active_tools:
        tool_instance = orchestrator.active_tools[task_id]
        logger.info(
            f"Found active tool for task {task_id} in state {tool_instance.state}"
        )
    else:
        tool_instance = ToolRecovery.recover_tool(task_id)
        if tool_instance:
            orchestrator.active_tools[task_id] = tool_instance
            logger.info(
                f"Recovered tool from disk for task {task_id} in state {tool_instance.state}"
            )
        else:
            if task.task_status not in [TaskStatus.NEW, TaskStatus.PLANNING]:
                return ToolResponse(
                    status="error",
                    message=f"Task '{task_id}' has status '{task.task_status.value}'. Planning can only start on a 'new' task or resume a 'planning' task.",
                )

            tool_instance = PlanTaskTool(task_id=task_id)
            orchestrator.active_tools[task_id] = tool_instance

            if task.task_status == TaskStatus.NEW:
                state_manager.update_task_status(task_id, TaskStatus.PLANNING)

            state_manager.update_tool_state(task_id, tool_instance)
            logger.info(f"Created new planning tool for task {task_id}")

    try:
        persona_config = load_persona(tool_instance.persona_name or "planning")
    except FileNotFoundError as e:
        return ToolResponse(status="error", message=str(e))

    prompt_context = tool_instance.context_store.copy()
    prompt = prompter.generate_prompt(
        task=task,
        tool_name=tool_instance.tool_name,
        state=tool_instance.state,
        persona_config=persona_config,
        additional_context=prompt_context,
    )

    message = (
        f"Planning initiated for task '{task_id}'."
        if tool_instance.state == PlanTaskState.CONTEXTUALIZE.value
        else f"Resumed planning for task '{task_id}' from state '{tool_instance.state}'."
    )

    return ToolResponse(status="success", message=message, next_prompt=prompt)
```

#### **6. Replace `src/alfred/tools/submit_work.py` and `src/alfred/tools/provide_review.py`:**
These files are only modified to call the new state manager methods.
- In `submit_work.py`: `state_manager.save_tool_state(task_id, active_tool)` becomes `state_manager.update_tool_state(task_id, active_tool)`.
- In `provide_review.py`:
    - `state_manager.save_tool_state(task_id, active_tool)` becomes `state_manager.update_tool_state(task_id, active_tool)`.
    - At tool completion, `update_task_status(...)` and `state_manager.clear_tool_state(...)` must be used.

**Executor's Action for `submit_work.py`:**
Replace the file with this content.
```python
# src/alfred/tools/submit_work.py
import json

from pydantic import ValidationError

from src.alfred.core.prompter import prompter
from src.alfred.lib.artifact_manager import artifact_manager
from src.alfred.lib.logger import get_logger
from src.alfred.lib.task_utils import load_task
from src.alfred.models.schemas import ToolResponse
from src.alfred.orchestration.orchestrator import orchestrator
from src.alfred.orchestration.persona_loader import load_persona
from src.alfred.state.manager import state_manager
from src.alfred.constants import ArtifactKeys, Triggers, ResponseStatus, LogMessages, ErrorMessages

logger = get_logger(__name__)


def submit_work_impl(task_id: str, artifact: dict) -> ToolResponse:
    """Implements the logic for submitting a work artifact to the active tool."""
    if task_id not in orchestrator.active_tools:
        return ToolResponse(status=ResponseStatus.ERROR, message=f"{LogMessages.NO_ACTIVE_TOOL.format(task_id=task_id)} Cannot submit work.")

    active_tool = orchestrator.active_tools[task_id]
    task = load_task(task_id)
    if not task:
        return ToolResponse(status=ResponseStatus.ERROR, message=LogMessages.TASK_NOT_FOUND.format(task_id=task_id))

    current_state_enum = active_tool.state
    current_state_val = active_tool.state.value if hasattr(active_tool.state, "value") else active_tool.state
    artifact_model = active_tool.artifact_map.get(current_state_enum)

    if artifact_model:
        try:
            validated_artifact = artifact_model.model_validate(artifact)
            logger.info(LogMessages.ARTIFACT_VALIDATED.format(state=current_state_val, model=artifact_model.__name__))
        except ValidationError as e:
            error_msg = f"{ErrorMessages.VALIDATION_FAILED.format(state=current_state_val)}. The submitted artifact does not match the required structure.\n\nValidation Errors:\n{e}"
            return ToolResponse(status=ResponseStatus.ERROR, message=error_msg)
    else:
        validated_artifact = artifact

    try:
        persona_config = load_persona(active_tool.persona_name)
    except FileNotFoundError as e:
        return ToolResponse(status=ResponseStatus.ERROR, message=str(e))

    trigger = Triggers.submit_trigger(current_state_val)
    if not hasattr(active_tool, trigger):
        return ToolResponse(status=ResponseStatus.ERROR, message=f"Invalid action: cannot submit from state '{current_state_val}'. No trigger '{trigger}' exists.")

    next_transitions = active_tool.machine.get_transitions(source=active_tool.state, trigger=trigger)
    if not next_transitions:
        return ToolResponse(status=ResponseStatus.ERROR, message=f"No valid transition for trigger '{trigger}' from state '{active_tool.state}'.")
    next_state = next_transitions[0].dest

    temp_context = active_tool.context_store.copy()
    artifact_key = ArtifactKeys.get_artifact_key(current_state_val)
    temp_context[artifact_key] = validated_artifact
    temp_context[ArtifactKeys.ARTIFACT_CONTENT_KEY] = json.dumps(artifact, indent=2)

    next_prompt = prompter.generate_prompt(
        task=task,
        tool_name=active_tool.tool_name,
        state=next_state,
        persona_config=persona_config,
        additional_context=temp_context,
    )

    active_tool.context_store[artifact_key] = validated_artifact
    artifact_manager.append_to_scratchpad(task_id=task_id, state_name=current_state_val, artifact=validated_artifact, persona_config=persona_config)
    
    getattr(active_tool, trigger)()
    logger.info(LogMessages.STATE_TRANSITION.format(task_id=task_id, trigger=trigger, state=active_tool.state))

    state_manager.update_tool_state(task_id, active_tool)

    return ToolResponse(status=ResponseStatus.SUCCESS, message="Work submitted. Awaiting review.", next_prompt=next_prompt)
```

**Executor's Action for `provide_review.py`:**
Replace the file with this content.
```python
# src/alfred/tools/provide_review.py
import json

from src.alfred.models.schemas import ToolResponse, TaskStatus
from src.alfred.orchestration.orchestrator import orchestrator
from src.alfred.lib.task_utils import load_task
from src.alfred.core.prompter import prompter
from src.alfred.orchestration.persona_loader import load_persona
from src.alfred.lib.logger import get_logger, cleanup_task_logging
from src.alfred.state.manager import state_manager
from src.alfred.constants import ToolName, Paths, PlanTaskStates, ArtifactKeys, Triggers, ResponseStatus, LogMessages, ErrorMessages

logger = get_logger(__name__)


def provide_review_impl(task_id: str, is_approved: bool, feedback_notes: str = "") -> ToolResponse:
    """Processes review feedback, advancing the active tool's State Machine."""
    if task_id not in orchestrator.active_tools:
        return ToolResponse(status=ResponseStatus.ERROR, message=LogMessages.NO_ACTIVE_TOOL.format(task_id=task_id))

    active_tool = orchestrator.active_tools[task_id]
    task = load_task(task_id)
    if not task:
        return ToolResponse(status=ResponseStatus.ERROR, message=LogMessages.TASK_NOT_FOUND.format(task_id=task_id))

    trigger = Triggers.AI_APPROVE if is_approved else Triggers.REQUEST_REVISION
    if not hasattr(active_tool, trigger):
        return ToolResponse(status=ResponseStatus.ERROR, message=f"Invalid action: cannot trigger '{trigger}' from state '{active_tool.state}'.")

    getattr(active_tool, trigger)()
    logger.info(LogMessages.STATE_TRANSITION.format(task_id=task_id, trigger=trigger, state=active_tool.state))
    state_manager.update_tool_state(task_id, active_tool)

    if active_tool.is_terminal:
        final_task_status = TaskStatus.READY_FOR_DEVELOPMENT
        state_manager.update_task_status(task_id, final_task_status)
        state_manager.clear_tool_state(task_id)

        del orchestrator.active_tools[task_id]
        cleanup_task_logging(task_id)
        logger.info(f"Tool '{active_tool.tool_name}' for task {task_id} completed. Task status updated to '{final_task_status.value}'.")
        
        handoff_message = f"Planning for task {task_id} is complete. The task is now '{final_task_status.value}'. To begin implementation, use the 'implement_task' tool."
        return ToolResponse(status=ResponseStatus.SUCCESS, message=f"Tool '{active_tool.tool_name}' completed successfully.", next_prompt=handoff_message)
    else:
        persona_config = load_persona(active_tool.persona_name)
        additional_context = active_tool.context_store.copy()
        additional_context["feedback_notes"] = feedback_notes or ""
        next_prompt = prompter.generate_prompt(
            task=task,
            tool_name=active_tool.tool_name,
            state=active_tool.state,
            persona_config=persona_config,
            additional_context=additional_context,
        )
        message = "Review approved. Proceeding to next step." if is_approved else "Revision requested."
        return ToolResponse(status=ResponseStatus.SUCCESS, message=message, next_prompt=next_prompt)
```