### **TASK: AL-06 (To be executed *after* `plan_task` implementation is complete)**

#### **Title:**
Test Framework: Implement "Simulated Reality" Testing Harness

#### **Context:**
To ensure the reliability and correctness of the Alfred Command Suite, we require a robust testing strategy that validates the true, end-to-end behavior of our tools. We will not use fragile mocks for core components. Instead, we will build a "Simulated Reality" testing harness using `pytest`. This harness will create a temporary, isolated project environment (`.alfred-test`) for each test run, allowing us to test our tools against a real file system. This task establishes the foundational fixtures and helpers needed to write high-fidelity integration tests for all our workflow tools.

#### **Implementation Details:**
1.  **Configure `pytest`:** Set up the `pytest.ini` or `pyproject.toml` file to define our test environment.
2.  **Create a `conftest.py` file.** This is where our primary testing fixtures will live.
3.  **Implement the `alfred_test_project` fixture:** This will be the cornerstone of our testing suite. This `pytest` fixture will:
    a.  Use Python's `tmp_path` fixture to create a unique temporary directory for a test.
    b.  `os.chdir()` into this temporary directory before the test runs.
    c.  Yield a `TestProject` helper class instance to the test function.
    d.  After the test completes, `os.chdir()` back to the original directory. The `tmp_path` fixture will automatically handle cleanup.
4.  **Create a `TestProject` helper class:** This class will be yielded by the fixture and will provide high-level methods to interact with the test environment, making our tests clean and readable. It will have methods like:
    *   `initialize(provider: str)`: A wrapper around the real `initialize_project` tool.
    *   `create_task_file(task: Task)`: A helper to create the `task.json` file in the correct location.
    *   `run_tool(tool_name: str, **kwargs)`: A helper to call a tool on the server.
    *   `get_task_state(task_id: str)`: A helper to load and return the `Task` object from the test workspace.
    *   `get_artifact_path(task_id: str, artifact_name: str)`: A helper to resolve paths within the `.alfred-test` directory.

**Dev Notes:**
*   This harness is a one-time investment that will dramatically accelerate our ability to write reliable tests for all subsequent tools.
*   All file paths within our application code must be refactored to use `pathlib.Path` and relative paths (e.g., `Path.cwd() / ".alfred"`) to ensure they work correctly when the current working directory is changed by the test harness. We must eliminate all hardcoded absolute paths.
*   The use of `pytest` fixtures is the standard for managing test setup and teardown cleanly.

**Files to Modify/Create:**

1.  **`tests/conftest.py` (NEW FILE):**
    ```python
    # tests/conftest.py
    import pytest
    import os
    from pathlib import Path
    from typing import Generator
    
    from src.alfred.tools.initialize import initialize_project # Import the real tool logic
    from src.alfred.models.schemas import Task
    from src.alfred.lib.task_utils import save_task

    class TestProject:
        """A helper class to manage a temporary Alfred project for testing."""
        def __init__(self, root_path: Path):
            self.root = root_path
            self.alfred_dir = self.root / ".alfred-test"
            # Override settings to point to our test directory
            # This requires a settings system that can be dynamically configured.
            # We will need to refactor settings.py to support this.

        def initialize(self, provider: str = "local"):
            # Note: This assumes initialize_project can be run programmatically
            # and that its settings can be overridden to use our test directory.
            # We will need to refactor initialize_project for testability.
            initialize_project(provider, test_dir=self.alfred_dir)

        def create_task_file(self, task: Task):
            # This uses a refactored save_task that can accept a root dir.
            save_task(task, root_dir=self.alfred_dir)
            
        # ... other helper methods ...

    @pytest.fixture
    def alfred_test_project(tmp_path: Path) -> Generator[TestProject, None, None]:
        """Pytest fixture to create and manage an isolated Alfred project for a test."""
        original_cwd = Path.cwd()
        os.chdir(tmp_path)
        
        test_project = TestProject(tmp_path)
        
        yield test_project
        
        os.chdir(original_cwd)
    ```

2.  **Refactor `src/alfred/config/settings.py` and tool functions:**
    *   All functions that currently write to `.alfred` (like `initialize_project`, `save_task`) must be refactored to accept an optional `root_dir: Path` argument. If this argument is `None`, they default to `Path.cwd()`. This makes them testable.

#### **Acceptance Criteria:**
*   A `tests/conftest.py` file exists with the `alfred_test_project` fixture.
*   The fixture successfully creates a temporary directory and an `.alfred-test` subdirectory within it.
*   Helper functions like `initialize()` and `create_task_file()` correctly operate within the temporary test directory.
*   Relevant application code (e.g., `settings.py`, `task_utils.py`) is refactored to be testable by allowing the root directory to be overridden.

#### **AC Verification:**
*   Create a simple test `test_project_initialization(alfred_test_project: TestProject)`.
*   Inside the test, call `alfred_test_project.initialize()`.
*   Assert that the directory `alfred_test_project.root / ".alfred-test"` exists.
*   Assert that the test does not create or modify any `.alfred` directory in the actual project root.

#### **Unit Tests:**
*   This task *is* the creation of our testing foundation. The "Unit Tests" are the integration tests we will write for `plan_task` *using* this new harness in the subsequent task.
