### **TASK: AL-16**

#### **Title:**
Tool Content: Complete `plan_task` Strategy Phase

#### **Context:**
The `plan_task` tool can now handle the initial `Contextualize` phase. We will now build out the second major stage: `Strategize`. This involves defining the Pydantic model for the `StrategyArtifact` and creating the detailed prompt templates that guide the AI through creating and reviewing a high-level technical strategy.

#### **Implementation Details:**
1.  **Define the `StrategyArtifact` model.** In `src/alfred/models/planning_artifacts.py`, define the Pydantic model for the strategy artifact. The `risk_analysis` and `new_dependencies` fields must be optional.
2.  **Map the artifact in the State Machine.** In `src/alfred/core/workflow.py`, add the new `StrategyArtifact` model to the `artifact_map` for the `PlanTaskState.STRATEGIZE` state.
3.  **Implement the `strategize.md` prompt.** Replace the `TODO` content with the full prompt. This prompt must instruct the AI to produce a JSON object matching the `StrategyArtifact` model.
4.  **Implement the `review_strategy.md` prompt.** This prompt will be used for the two-step review of the generated strategy. It must instruct the AI to self-critique against the original `Task`'s acceptance criteria.

**Dev Notes:**
*   We are building the workflow step-by-step. The `strategize` prompt is critical as it sets the high-level direction for the entire plan.
*   The use of optional fields in the Pydantic model (`str | None = None`) is the correct way to handle fields that may not always be present.

**Files to Modify/Create:**

1.  **`src/alfred/models/planning_artifacts.py` (MODIFY):**
    ```python
    # src/alfred/models/planning_artifacts.py
    # ... imports ...
    # from .schemas import SLOT # Already there

    class ContextAnalysisArtifact(BaseModel):
        # ... as before ...

    # --- DEFINE THIS NEW MODEL ---
    class StrategyArtifact(BaseModel):
        high_level_strategy: str = Field(description="A concise summary of the proposed technical strategy.")
        key_components: List[str] = Field(description="A list of the major new or modified components, classes, or modules.")
        new_dependencies: List[str] = Field(default_factory=list, description="Optional list of new libraries required, e.g., 'pyjwt', 'passlib'.")
        risk_analysis: str | None = Field(None, description="Optional analysis of potential risks or architectural trade-offs.")
    
    # ... other models ...
    ```

2.  **`src/alfred/core/workflow.py` (MODIFY `PlanTaskTool`):**
    ```python
    # ...
    # from src.alfred.models.planning_artifacts import ContextAnalysisArtifact, StrategyArtifact, ...
    
    self.artifact_map = {
        PlanTaskState.CONTEXTUALIZE: ContextAnalysisArtifact,
        PlanTaskState.STRATEGIZE: StrategyArtifact, # <-- ADD THIS MAPPING
        # ...
    }
    # ...
    ```

3.  **`src/alfred/templates/prompts/plan_task/strategize.md` (REPLACE):**
    ```markdown
    # ROLE: {{ persona.name }}, {{ persona.title }}
    # TOOL: `alfred.plan_task`
    # TASK: {{ task.task_id }}
    # STATE: strategize

    Context is verified. The human developer has provided all necessary clarifications. We will now create the high-level technical strategy for '{{ task.title }}'. This strategy will serve as the guiding principle for the detailed design.

    ---
    ### **Thinking Methodology**
    {% for principle in persona.thinking_methodology %}
    - {{ principle }}
    {% endfor %}

    ---
    ### **Directive: Develop Technical Strategy**

    Based on the full task context, develop a concise technical strategy.

    - **Strategy:** Define the overall technical approach (e.g., "Create a new microservice," "Refactor the existing `UserService`," "Add a new middleware layer").
    - **Components:** List the major new or modified components, classes, or modules.
    - **Dependencies (Optional):** List any new third-party libraries that will be required.
    - **Risks (Optional):** Note any potential risks or important architectural trade-offs.

    ---
    ### **Required Action**

    You MUST now call `alfred.submit_work` with a `StrategyArtifact`.

    **Required Artifact Structure:**
    ```json
    {
      "high_level_strategy": "string",
      "key_components": ["string"],
      "new_dependencies": ["string", "Optional"],
      "risk_analysis": "string", "Optional"
    }
    ```
    ```

4.  **`src/alfred/templates/prompts/plan_task/review_strategy.md` (REPLACE):**
    ```markdown
    # ROLE: {{ persona.name }}, {{ persona.title }}
    # TOOL: `alfred.plan_task`
    # TASK: {{ task.task_id }}
    # STATE: review_strategy

    The initial technical strategy has been drafted. I will now perform a self-review to ensure its quality and alignment with the project goals before presenting it for human approval.

    ---
    ### **Directive: AI Self-Review**

    Critically evaluate the strategy you just created.
    
    **Review Checklist:**
    1.  **Goal Alignment:** Does the strategy directly address all acceptance criteria for '{{ task.title }}'?
    2.  **Feasibility:** Is the strategy technically sound and achievable within a reasonable scope?
    3.  **Completeness:** Are all key components and potential dependencies identified?
    4.  **Simplicity:** Is this the simplest viable approach, or is there a less complex alternative?

    ---
    ### **Required Action**

    If the strategy passes your self-review, call `alfred.provide_review` with `is_approved=True`. The `feedback_notes` should contain a brief summary of your review (e.g., "Strategy is sound and covers all ACs.").

    If the strategy is flawed, call `alfred.provide_review` with `is_approved=False` and provide detailed `feedback_notes` on what needs to be corrected. You will then be prompted to create a new strategy.
    ```

#### **Acceptance Criteria:**
*   The `StrategyArtifact` model is correctly defined in `planning_artifacts.py`.
*   The `PlanTaskTool`'s `artifact_map` is updated to include the mapping for the `STRATEGIZE` state.
*   The `strategize.md` and `review_strategy.md` prompt templates are implemented exactly as specified.

#### **AC Verification:**
*   Using the `alfred_test_project` harness, create a test that successfully advances the `plan_task` tool through the `CONTEXTUALIZE` phase and into the `STRATEGIZE` state.
*   The test will then call `submit_work` with a valid `StrategyArtifact`.
*   Assert that the State Machine transitions to `REVIEW_STRATEGY`.
*   Assert that the `scratchpad.md` file contains the rendered `StrategyArtifact`.

#### **Unit Tests:**
*   **`tests/tools/test_planning_lifecycle.py` (New or existing):** Add a test `test_strategy_phase_submission_and_review` that follows the AC Verification steps. This test will build upon the state left by the context phase tests.