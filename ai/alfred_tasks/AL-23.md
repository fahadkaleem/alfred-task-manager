### **TASK: AL-23**

#### **Title:**
Architectural Fix: Implement Context Persistence in Workflow Tools

#### **Context:**
Our State Machine is currently stateless between transitions, causing critical failures when a subsequent state's prompt requires an artifact from a previous state. We must implement a context persistence mechanism within our `BaseWorkflowTool`. This will allow us to store the results of each approved stage (e.g., the `StrategyArtifact`) and inject them as `additional_context` into the prompts for the next stage, ensuring a continuous and logical flow of information.

#### **Implementation Details:**
1.  **Add a `context_store` to `BaseWorkflowTool`.** In `src/alfred/core/workflow.py`, add a new instance attribute `self.context_store: Dict[str, Any] = {}` to the `BaseWorkflowTool`'s `__init__` method.
2.  **Refactor `submit_work_impl`.** This tool is where artifacts are first received. In `src/alfred/tools/submit_work.py`, after validating the artifact, we must store it in the active tool's `context_store`. The key should be predictable, for example, `{state_name}_artifact`.
3.  **Refactor `provide_review_impl`.** This is where the context passing happens. In `src/alfred/tools/provide_review.py`:
    *   When an approval (`is_approved=True`) happens, the logic must now **pass the entire `active_tool.context_store`** into the `additional_context` argument of the `prompter.generate_prompt` call.
4.  **Update `design.md` Template.** The template at `src/alfred/templates/prompts/plan_task/design.md` must be updated to access the artifact from the context store: `{{ context_store.strategize_artifact | tojson(indent=2) }}`.

**Dev Notes:**
*   This is a fundamental change to our core workflow engine. The `context_store` acts as the tool's "short-term memory" during its lifecycle.
*   When a tool's lifecycle is complete (reaches the terminal state), its entry in `orchestrator.active_tools` is deleted, automatically clearing this memory, which is the correct behavior.

**Files to Modify/Create:**

1.  **`src/alfred/core/workflow.py` (MODIFY `BaseWorkflowTool`):**
    ```python
    # src/alfred/core/workflow.py
    class BaseWorkflowTool:
        def __init__(self, ...):
            # ...
            self.context_store: Dict[str, Any] = {}
            # ...
    ```

2.  **`src/alfred/tools/submit_work.py` (MODIFY `submit_work_impl`):**
    ```python
    # src/alfred/tools/submit_work.py
    def submit_work_impl(task_id: str, artifact: dict) -> ToolResponse:
        # ... (find active_tool, task, validate artifact) ...
        
        # --- NEW: Store validated artifact in the tool's context ---
        state_key = f"{active_tool.state.value}_artifact"
        active_tool.context_store[state_key] = validated_artifact
        logger.info(f"Stored artifact in context_store with key '{state_key}'.")

        # ... (rest of the function: persist to scratchpad, transition state, generate prompt) ...
    ```

3.  **`src/alfred/tools/provide_review.py` (MODIFY `provide_review_impl`):**
    ```python
    # src/alfred/tools/provide_review.py
    def provide_review_impl(...):
        # ... (logic to find active_tool and trigger SM) ...
        
        # ... (Terminal state check remains the same) ...
        
        # --- REVISED: Mid-workflow review logic ---
        else:
            # ...
            additional_context = active_tool.context_store.copy() # Start with the full context
            if not is_approved and feedback_notes:
                additional_context["feedback_notes"] = feedback_notes
            
            next_prompt = prompter.generate_prompt(
                task=task,
                tool_name=active_tool.tool_name,
                state=active_tool.state,
                persona_config=persona_config,
                additional_context=additional_context
            )
            # ...
    ```

4.  **`src/alfred/templates/prompts/plan_task/design.md` (MODIFY):**
    ```markdown
    # ...
    **Approved Strategy:**
    ```json
    {{ context_store.strategize_artifact.model_dump_json(indent=2) }}
    ```
    ...
    ```

#### **Acceptance Criteria & AC Verification:**
*   After this fix, we will re-run the `VT-02` validation test from the point of approving the `StrategyArtifact`.
*   **Assert:** The `provide_review` call now succeeds without a `jinja2.exceptions.UndefinedError`.
*   **Assert:** The prompt generated for the `design` state correctly contains the JSON of the `StrategyArtifact` submitted in the previous step.
