### **TASK: AL-05**

#### **Title:**
Tool Implementation: Architect the `plan_task` Server Entry Point

#### **Context:**
With the `PlanTaskTool`'s internal State Machine defined (`AL-02`) and the `Prompter` engine ready (`AL-04`), we must now expose this capability to the user. This task involves creating the public-facing `plan_task` tool in `server.py`. This tool will act as the "controller" in our architecture. It will be responsible for receiving the user's request, performing essential precondition checks (e.g., verifying task status), initializing the `PlanTaskTool` instance, and kicking off the internal State Machine by generating the very first prompt. This task creates the crucial link between a user command and our internal workflow logic.

#### **Implementation Details:**
1.  **Reuse and Enhance the `Orchestrator` concept.** Our existing codebase has an `Orchestrator` singleton in `src/alfred/orchestration/orchestrator.py`. While we are moving away from a central orchestrator that manages the *entire* lifecycle, this class is the perfect place to manage the lifecycle of *active tool sessions*. We will refactor it to hold a dictionary of active tool instances, like `active_tools: Dict[str, BaseWorkflowTool]`.
2.  **Define the `plan_task` tool in `server.py`.** Add a new `@app.tool()` function. This function's docstring will be the official API contract, as we designed.
3.  **Implement the tool's core logic.** The Python code inside the `plan_task` function will perform the following steps:
    a.  **Load the `Task` object.** It will need a new utility function (e.g., `_load_task(task_id)`) to read the corresponding `Task` JSON file from the workspace.
    b.  **Precondition Check:** It will verify that `task.task_status` is `TaskStatus.NEW` or `TaskStatus.PLANNING`. If not, it will return an immediate, helpful error message guiding the user to the correct tool.
    c.  **Initialize `PlanTaskTool`:** It will create a new instance of our `PlanTaskTool` class (`from src.alfred.core.workflow import PlanTaskTool`).
    d.  **Register the Active Tool:** It will store this new instance in the `Orchestrator`'s `active_tools` dictionary, keyed by `task_id`. This is how we track which tool is currently running for which task.
    e.  **Generate the First Prompt:** It will use the `prompter` singleton (`from src.alfred.core.prompter import prompter`) to generate the prompt for the tool's initial state (`PlanTaskState.CONTEXTUALIZE`).
    f.  **Update Task Status:** It will update the `task.task_status` to `TaskStatus.PLANNING` and save the `Task` object back to disk.
    g.  **Return `ToolResponse`:** It will return the initial prompt to the user.

**Dev Notes:**
*   This task requires careful integration of our previously defined components: `Task` schema, `PlanTaskTool`, and `Prompter`.
*   The `Orchestrator` is being repurposed from a global workflow manager to a session manager for active tools. This is a key architectural refinement.
*   We must build a small, reusable utility function, likely in `src/alfred/lib/utils.py`, to handle loading and saving `Task` JSON objects to prevent code duplication.

**Files to Modify/Create:**

1.  **`src/alfred/orchestration/orchestrator.py` (REFACTOR):**
    ```python
    # src/alfred/orchestration/orchestrator.py
    # ... imports ...
    from typing import Dict
    from src.alfred.core.workflow import BaseWorkflowTool # Important import

    class Orchestrator:
        _instance = None
        _initialized = False

        def __new__(cls):
            # ... (singleton logic remains the same) ...

        def __init__(self):
            if self._initialized:
                return
            # This now holds active TOOL instances, not a single runtime
            self.active_tools: Dict[str, BaseWorkflowTool] = {} 
            self._initialized = true

    orchestrator = Orchestrator()
    ```

2.  **`src/alfred/lib/task_utils.py` (NEW FILE):**
    ```python
    # src/alfred/lib/task_utils.py
    from pathlib import Path
    from src.alfred.config.settings import settings
    from src.alfred.models.schemas import Task, TaskStatus

    def load_task(task_id: str) -> Task | None:
        """Loads a Task object from its JSON file in the workspace."""
        task_file = settings.workspace_dir / task_id / "task.json"
        if not task_file.exists():
            return None
        return Task.model_validate_json(task_file.read_text())

    def save_task(task: Task) -> None:
        """Saves a Task object to its JSON file."""
        task_dir = settings.workspace_dir / task.task_id
        task_dir.mkdir(parents=True, exist_ok=True)
        task_file = task_dir / "task.json"
        task_file.write_text(task.model_dump_json(indent=2))

    def update_task_status(task_id: str, new_status: TaskStatus) -> Task:
        """Loads a task, updates its status, and saves it."""
        task = load_task(task_id)
        if not task:
            raise FileNotFoundError(f"Task {task_id} not found.")
        task.task_status = new_status
        save_task(task)
        return task
    ```

3.  **`src/alfred/server.py` (MODIFY):**
    ```python
    # src/alfred/server.py
    # ... other imports ...
    # --- NEW IMPORTS ---
    from src.alfred.orchestration.orchestrator import orchestrator
    from src.alfred.core.workflow import PlanTaskTool, PlanTaskState
    from src.alfred.core.prompter import prompter
    from src.alfred.lib.task_utils import load_task, update_task_status
    from src.alfred.models.schemas import TaskStatus
    
    # ... initialize_project tool remains ...

    # --- ADD THE NEW plan_task TOOL ---
    @app.tool()
    async def plan_task(task_id: str) -> ToolResponse:
        """
        Initiates the detailed technical planning for a specific task.

        This is the primary tool for transforming a high-level task or user story
        into a concrete, machine-executable 'Execution Plan' composed of SLOTs.
        A SLOT (Spec, Location, Operation, Taskflow) is an atomic unit of work.

        This tool manages a multi-step, interactive planning process...
        [... rest of the docstring as designed ...]
        """
        task = load_task(task_id)
        if not task:
            return ToolResponse(status="error", message=f"Task '{task_id}' not found.")

        # Precondition Check
        allowed_statuses = [TaskStatus.NEW, TaskStatus.PLANNING]
        if task.task_status not in allowed_statuses:
            return ToolResponse(
                status="error",
                message=f"Task '{task_id}' is in status '{task.task_status.value}'. Cannot start planning. It must be in 'new' or 'planning' state."
            )
        
        # Initialize and register the tool instance
        plan_tool_instance = PlanTaskTool(task_id)
        orchestrator.active_tools[task_id] = plan_tool_instance
        
        # Load persona config (we'll need a utility for this, but for now, mock it)
        # TODO: Implement a persona_loader utility in a future task
        persona_config = {"name": "Alex", "title": "Solution Architect"}

        # Generate the first prompt for the initial state
        initial_prompt = prompter.generate_prompt(
            task=task,
            tool_name="plan_task",
            state=plan_tool_instance.state, # Will be PlanTaskState.CONTEXTUALIZE
            persona_config=persona_config
        )

        # Update status and save
        update_task_status(task_id, TaskStatus.PLANNING)

        return ToolResponse(
            status="success",
            message=f"Planning initiated for task '{task_id}'. Follow the instructions to proceed.",
            next_prompt=initial_prompt
        )

    # ... commented out legacy tools ...
    ```

#### **Acceptance Criteria:**
*   The `Orchestrator` class is refactored to manage a dictionary of `active_tools`.
*   A new `task_utils.py` library exists with `load_task`, `save_task`, and `update_task_status` functions.
*   The `plan_task` tool is defined in `server.py` with the correct docstring.
*   The tool correctly performs the precondition check on the task's status.
*   The tool successfully initializes a `PlanTaskTool` instance and registers it with the `Orchestrator`.
*   The tool uses the `Prompter` to generate the prompt for the initial `CONTEXTUALIZE` state.
*   The tool updates the task's status to `PLANNING`.

#### **AC Verification:**
*   Create a dummy `task.json` file in a test workspace directory with `status: "new"`.
*   Call the `plan_task` tool via an MCP client.
*   Assert that the returned `ToolResponse` has `status: "success"` and contains a `next_prompt`.
*   Verify that the `task.json` file on disk has been updated to `status: "planning"`.
*   Create another dummy `task.json` with `status: "in_development"`. Call the tool again.
*   Assert that the returned `ToolResponse` has `status: "error"` with the correct message.

#### **Unit Tests:**
*   Create a new test file `tests/tools/test_plan_task_tool.py`.
*   Write a test `test_plan_task_success_initialization` that mocks `load_task` and `prompter` and verifies the success path.
*   Write a test `test_plan_task_fails_with_invalid_status` that sets up a `Task` with an incorrect status and asserts that the tool returns an error.
*   Write a test `test_plan_task_registers_tool_in_orchestrator` to confirm the `PlanTaskTool` instance is correctly added to `orchestrator.active_tools`.
*   Write unit tests for the new functions in `tests/lib/test_task_utils.py`.