### **TASK: AL-07**

#### **Title:**
Tool Implementation: Build `plan_task` Controller Logic

#### **Context:**
With the foundational data schemas (`Task`, `SLOT`), State Machine (`PlanTaskTool`), and `Prompter` engine in place, we must now build the controller logic for the `plan_task` tool. This controller acts as the bridge between a user's command and the tool's internal workflow. It is responsible for loading the task context, performing precondition checks, initializing the tool's State Machine instance, and generating the first conversational prompt to kick off the planning process. This is the final step in making the `plan_task` command fully operational.

#### **Implementation Details:**
1.  **Create a new `plan_task.py` tool module.** All logic for the `plan_task` tool will be encapsulated here to keep `server.py` clean. This module will contain a single function, `plan_task_impl`.
2.  **Implement the `plan_task_impl` function.** This async function will accept `task_id: str` and perform the core controller logic:
    a.  **Load the `Task` object.** Use the `load_task` utility we will create in the next step.
    b.  **Precondition Check:** Verify that `task.task_status` is `TaskStatus.NEW`. If not, return an error `ToolResponse`.
    c.  **Initialize `PlanTaskTool`:** Create a new instance of the `PlanTaskTool` class (`from src.alfred.core.workflow import PlanTaskTool`).
    d.  **Register Active Tool:** Store this new instance in the `Orchestrator`'s `active_tools` dictionary, keyed by `task_id`. (`from src.alfred.orchestration.orchestrator import orchestrator`).
    e.  **Load Persona Config:** We need a small utility to load the `planning.yml` persona file.
    f.  **Generate First Prompt:** Use the `prompter` singleton to generate the prompt for the tool's initial state (`PlanTaskState.CONTEXTUALIZE`).
    g.  **Update Task Status:** Update the task's status to `TaskStatus.PLANNING` using `update_task_status`.
    h.  **Return `ToolResponse`:** Return the initial prompt and a success message.
3.  **Create `task_utils.py` and `persona_loader.py` libraries.** To support the controller logic and promote code reuse, we will create two small library modules.
    *   `task_utils.py` will contain `load_task`, `save_task`, and `update_task_status`.
    *   `persona_loader.py` will contain a simple function `load_persona(persona_name: str)` that reads and parses the corresponding `.yml` file from the `personas` directory.
4.  **Update `server.py` to call the new implementation.** The `plan_task` function in `server.py` will now simply call `await plan_task_impl(task_id)`.

**Dev Notes:**
*   This architecture keeps the main `server.py` file extremely clean, acting only as a dispatcher. The actual business logic for each tool lives in its own dedicated module.
*   The `Orchestrator` is now officially acting as our session manager for active tools.

**Files to Modify/Create:**

1.  **`src/alfred/lib/task_utils.py` (NEW FILE):** (Create this file with `load_task`, `save_task`, `update_task_status` as previously designed in AL-05 spec).
2.  **`src/alfred/lib/persona_loader.py` (NEW FILE):**
    ```python
    # src/alfred/lib/persona_loader.py
    import yaml
    from typing import Dict, Any
    from src.alfred.config.settings import settings

    def load_persona(persona_name: str) -> Dict[str, Any]:
        """Loads and parses a persona YAML file."""
        persona_file = settings.alfred_dir / "personas" / f"{persona_name}.yml"
        if not persona_file.exists():
            # Fallback to packaged personas
            persona_file = settings.packaged_personas_dir / f"{persona_name}.yml"
            if not persona_file.exists():
                raise FileNotFoundError(f"Persona config '{persona_name}.yml' not found.")
        
        with open(persona_file, 'r') as f:
            return yaml.safe_load(f)
    ```

3.  **`src/alfred/tools/plan_task.py` (NEW FILE):**
    ```python
    # src/alfred/tools/plan_task.py
    from src.alfred.models.schemas import ToolResponse, TaskStatus
    from src.alfred.lib.task_utils import load_task, update_task_status
    from src.alfred.lib.persona_loader import load_persona
    from src.alfred.core.workflow import PlanTaskTool
    from src.alfred.core.prompter import prompter
    from src.alfred.orchestration.orchestrator import orchestrator

    async def plan_task_impl(task_id: str) -> ToolResponse:
        """Implementation logic for the plan_task tool."""
        task = load_task(task_id)
        if not task:
            return ToolResponse(status="error", message=f"Task '{task_id}' not found.")

        # Precondition Check
        if task.task_status != TaskStatus.NEW:
            return ToolResponse(
                status="error",
                message=f"Task '{task_id}' has status '{task.task_status.value}'. Planning can only start on a 'new' task."
            )

        tool_instance = PlanTaskTool(task_id=task_id)
        orchestrator.active_tools[task_id] = tool_instance
        
        try:
            # The persona for plan_task is 'planning'
            persona_config = load_persona("planning") 
        except FileNotFoundError as e:
            return ToolResponse(status="error", message=str(e))

        initial_prompt = prompter.generate_prompt(
            task=task,
            tool_name="plan_task",
            state=tool_instance.state,
            persona_config=persona_config
        )

        update_task_status(task_id, TaskStatus.PLANNING)

        return ToolResponse(
            status="success",
            message=f"Planning initiated for task '{task_id}'.",
            next_prompt=initial_prompt
        )
    ```

#### **Acceptance Criteria:**
*   The `plan_task` tool in `server.py` successfully calls the `plan_task_impl` function.
*   `plan_task_impl` correctly loads a `Task` object.
*   The tool correctly rejects a task that is not in the `NEW` state.
*   The tool successfully creates a `PlanTaskTool` instance and stores it in the `orchestrator.active_tools` dictionary.
*   The tool successfully loads the `planning.yml` persona configuration.
*   The tool successfully uses the `prompter` to generate the initial prompt.
*   The tool updates the task's status to `PLANNING`.

#### **AC Verification:**
*   Using the `alfred_test_project` fixture:
    1.  Create a dummy `task.json` file with `task_status: "new"`.
    2.  Create a dummy `personas/planning.yml` file.
    3.  Create a dummy `templates/prompts/plan_task/contextualize.md` template.
    4.  Call the `plan_task(task_id)` tool.
    5.  Assert the response is successful and contains a rendered prompt.
    6.  Load the task state and assert its status is now `"planning"`.
    7.  Check `orchestrator.active_tools` and confirm an instance of `PlanTaskTool` is present for the task ID.

#### **Unit Tests:**
*   **`tests/tools/test_plan_task.py`:**
    *   Write a test `test_plan_task_impl_success` that uses the `alfred_test_project` fixture to verify the full success path.
    *   Write a test `test_plan_task_impl_invalid_status_error` to verify the precondition check.
    *   Write a test `test_plan_task_impl_task_not_found_error` for the case where `load_task` returns `None`.
*   **`tests/lib/test_persona_loader.py`:**
    *   Write tests for the `load_persona` function, including a success case and a `FileNotFoundError` case.
