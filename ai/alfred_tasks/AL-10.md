### **TASK: AL-10**

#### **Title:**
Test Framework: Implement "Simulated Reality" Testing Harness

#### **Context:**
To ensure the reliability and correctness of the Alfred Command Suite, we require a robust testing strategy that validates the true, end-to-end behavior of our tools. We will not use fragile mocks for core components. Instead, we will build a "Simulated Reality" testing harness using `pytest`. This harness will create a temporary, isolated project environment (`.alfred-test`) for each test run, allowing us to test our tools against a real file system. This task establishes the foundational fixtures and helpers needed to write high-fidelity integration tests for all our workflow tools.

#### **CRITICAL: DO NOT USE MOCKING**
This testing framework is being built specifically to AVOID mocking. The `AlfredTestProject` helper class is designed to interact with the real, implemented code and file system. No mocking libraries (`unittest.mock`, etc.) are permitted when testing the integrated workflow of a tool.

#### **Implementation Details:**
1.  **Create the `conftest.py` file.** This is the standard `pytest` location for shared fixtures.
2.  **Implement the `AlfredTestProject` helper class.** This class will provide a clean, high-level API for setting up test conditions and making assertions.
3.  **Implement the `alfred_test_project` fixture.** This fixture will manage the lifecycle of the test environment: creating the temporary directory, changing the working directory for the duration of the test, and handling cleanup.

**Dev Notes:**
*   To make our application code testable with this harness, any function that interacts with the file system (e.g., `load_task`, `initialize_project`) must be designed to use relative paths from the current working directory, not hardcoded paths. The `settings.py` file must be refactored to be dynamically configurable.
*   This harness is a one-time investment that will be reused for testing every tool in the Alfred Command Suite.

**Files to Create/Modify:**

1.  **`tests/conftest.py` (NEW FILE):**
    ```python
    # tests/conftest.py
    import pytest
    import os
    import shutil
    from pathlib import Path
    from typing import Generator, Any
    
    from src.alfred.models.schemas import Task
    from src.alfred.lib.task_utils import save_task as save_task_impl

    class AlfredTestProject:
        """A helper class to manage a temporary Alfred project for testing."""
        def __init__(self, root_path: Path):
            self.root: Path = root_path
            self.alfred_dir: Path = self.root / ".alfred"
            os.makedirs(self.alfred_dir, exist_ok=True)

        def initialize(self):
            """Initializes a base project structure inside the temp directory."""
            # This can be expanded to call the real initialize_project later
            (self.alfred_dir / "workspace").mkdir(exist_ok=True)
            (self.alfred_dir / "personas").mkdir(exist_ok=True)
            (self.alfred_dir / "templates" / "prompts").mkdir(parents=True, exist_ok=True)
            (self.alfred_dir / "config.json").write_text("{}")
            (self.alfred_dir / "state.json").write_text('{"tasks": {}}') # Legacy, will be removed
        
        def create_task_file(self, task: Task):
            """Saves a Task object to the test project's file system."""
            # We must be able to tell save_task where the .alfred dir is.
            save_task_impl(task, self.alfred_dir)

        def path(self, *parts: str) -> Path:
            """Helper to get a path inside the test project root."""
            return self.root.joinpath(*parts)

    @pytest.fixture
    def alfred_test_project(tmp_path: Path) -> Generator[AlfredTestProject, None, None]:
        """Pytest fixture to create and manage an isolated Alfred project for a test."""
        original_cwd = Path.cwd()
        # Change CWD to the temporary directory so the app writes files there
        os.chdir(tmp_path) 
        
        project = AlfredTestProject(tmp_path)
        project.initialize()

        yield project
        
        # Teardown: change back to original directory
        os.chdir(original_cwd)
    ```

2.  **Refactor `src/alfred/lib/task_utils.py` for Testability:**
    ```python
    # src/alfred/lib/task_utils.py
    # ... imports ...
    
    def _get_workspace_dir(alfred_dir: Optional[Path] = None) -> Path:
        """Helper to get the correct workspace directory."""
        if alfred_dir:
            return alfred_dir / "workspace"
        # If no specific dir, use settings (production path)
        from src.alfred.config.settings import settings
        return settings.workspace_dir

    def save_task(task: Task, alfred_dir: Optional[Path] = None):
        """Saves a Task object to its JSON file."""
        workspace_dir = _get_workspace_dir(alfred_dir)
        task_dir = workspace_dir / task.task_id
        task_dir.mkdir(parents=True, exist_ok=True)
        task_file = task_dir / "task.json"
        task_file.write_text(task.model_dump_json(indent=2))

    # Refactor load_task and update_task_status similarly...
    ```

#### **Acceptance Criteria:**
*   A `tests/conftest.py` file exists with the specified `AlfredTestProject` class and `alfred_test_project` fixture.
*   The `task_utils.py` functions are refactored to accept an optional `alfred_dir` argument, allowing them to be targeted at a test directory.

#### **AC Verification:**
*   Create a simple test `tests/system/test_harness.py`.
*   Write a test `test_fixture_creates_isolated_environment(alfred_test_project: AlfredTestProject)`.
*   Inside the test, call `alfred_test_project.create_task_file(...)`.
*   Assert that the `task.json` file is created inside the temporary directory structure (`tmp_path/.alfred/workspace/...`) and NOT in the main project's `.alfred` folder.

#### **Unit Tests:**
*   This task *is* the testing framework. Its validation will be its successful use in the tasks that follow.
