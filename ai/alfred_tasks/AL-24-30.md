### **TASK: AL-24 (Corrected)**

#### **Title:**
Core Models: Implement `ImplementTaskState` Enum and `ImplementationManifestArtifact`

#### **Context:**
This foundational task defines the data structures for the implementation workflow. We will create the State Machine enum (`ImplementTaskState`) to represent the internal lifecycle of the `implement_task` tool, and the `ImplementationManifestArtifact` Pydantic model for the final work submission.

#### **Implementation Details:**
This task involves modifying two existing files to add the new definitions.

#### **Files to Modify:**

1.  **`src/alfred_new/core/workflow.py` (MODIFY):**
    ```python
    # src/alfred_new/core/workflow.py
    # ... existing imports and PlanTaskState enum ...
    
    # --- ADD NEW ENUM ---
    class ImplementTaskState(str, Enum):
        """States for the ImplementTaskTool's internal State Machine."""
        DISPATCHING = "dispatching"
        IMPLEMENTING = "implementing"
        REVIEWING_MANIFEST = "reviewing_manifest"
        IMPLEMENTATION_VERIFIED = "implementation_verified"
    
    # ... BaseWorkflowTool and PlanTaskTool classes ...
    ```

2.  **`src/alfred_new/models/planning_artifacts.py` (MODIFY):**
    ```python
    # src/alfred_new/models/planning_artifacts.py
    # ... existing imports and artifact models ...
    
    # --- ADD NEW MODEL ---
    class ImplementationManifestArtifact(BaseModel):
        summary: str = Field(description="A high-level summary of the implemented changes.")
        completed_subtasks: List[str] = Field(description="A list of all completed subtask_ids, for verification.")
        testing_notes: str = Field(description="Notes on how to manually verify the changes or for the QA team.")
    ```

#### **Acceptance Criteria:**
*   The `ImplementTaskState` enum exists in `workflow.py`.
*   The `ImplementationManifestArtifact` class exists in `planning_artifacts.py`.
*   The project passes all existing tests.

---
### **TASK: AL-25 (Corrected)**

#### **Title:**
Core Workflow: Create `ImplementTaskTool` State Machine Class

#### **Context:**
This task defines the core logic and State Machine for the `implement_task` workflow. We will create the `ImplementTaskTool` class, which encapsulates the states, transitions, and artifact mappings for this phase.

#### **Implementation Details:**
This task involves adding the new `ImplementTaskTool` class to the `workflow.py` file.

#### **Files to Modify:**

1.  **`src/alfred_new/core/workflow.py` (MODIFY):**
    ```python
    # src/alfred_new/core/workflow.py
    # ... existing imports ...
    from src.alfred_new.models.planning_artifacts import (
        ContextAnalysisArtifact, StrategyArtifact, DesignArtifact, ExecutionPlanArtifact,
        ImplementationManifestArtifact # <-- Add this import
    )
    # ... existing PlanTaskState, ImplementTaskState, BaseWorkflowTool, PlanTaskTool ...
    
    # --- ADD NEW TOOL CLASS ---
    class ImplementTaskTool(BaseWorkflowTool):
        """Encapsulates the state and logic for the `implement_task` command."""
        def __init__(self, task_id: str, persona_name: str = "developer"):
            super().__init__(task_id, tool_name="implement_task", persona_name=persona_name)

            self.artifact_map = {
                ImplementTaskState.IMPLEMENTING: ImplementationManifestArtifact,
            }
            
            # This list will be populated by the mark_subtask_complete tool
            self.completed_subtasks: List[str] = []

            states = [state.value for state in ImplementTaskState]
            
            transitions = [
                {'trigger': 'dispatch', 'source': ImplementTaskState.DISPATCHING, 'dest': ImplementTaskState.IMPLEMENTING},
                {'trigger': 'submit_implementation', 'source': ImplementTaskState.IMPLEMENTING, 'dest': ImplementTaskState.REVIEWING_MANIFEST},
                *self._create_review_transitions(
                    source_state=ImplementTaskState.IMPLEMENTING, # Revisions go back to implementing
                    review_state=ImplementTaskState.REVIEWING_MANIFEST,
                    success_destination_state=ImplementTaskState.IMPLEMENTATION_VERIFIED
                ),
            ]
            
            self.machine = Machine(model=self, states=states, transitions=transitions, initial=ImplementTaskState.DISPATCHING)
    
        @property
        def is_terminal(self) -> bool:
            return self.state == ImplementTaskState.IMPLEMENTATION_VERIFIED
    ```

#### **Acceptance Criteria:**
*   The `ImplementTaskTool` class is correctly defined in `workflow.py`.
*   The State Machine is configured with the correct states and transitions.
*   The `completed_subtasks` attribute is present.

---
### **TASK: AL-26 (Corrected)**

#### **Title:**
Tools: Create `mark_subtask_complete` and `submit_implementation` Tools

#### **Context:**
This task creates the two essential "callback" tools for the implementation phase. `mark_subtask_complete` provides progress checkpointing, and `submit_implementation` signals the completion of all work.

#### **Implementation Details:**
We will create a new file `tools/progress.py` to house these new tool implementations.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/tools/progress.py` (NEW FILE):**
    ```python
    # src/alfred_new/tools/progress.py
    from src.alfred_new.models.schemas import ToolResponse
    from src.alfred_new.orchestration.orchestrator import orchestrator
    from src.alfred_new.state.manager import state_manager
    from src.alfred_new.core.workflow import ImplementTaskTool
    from src.alfred_new.tools.submit_work import submit_work_impl
    from src.alfred_new.lib.logger import get_logger

    logger = get_logger(__name__)

    def mark_subtask_complete_impl(task_id: str, subtask_id: str) -> ToolResponse:
        if task_id not in orchestrator.active_tools:
            return ToolResponse(status="error", message=f"No active tool found for task '{task_id}'.")
        
        active_tool = orchestrator.active_tools[task_id]
        if not isinstance(active_tool, ImplementTaskTool):
            return ToolResponse(status="error", message="`mark_subtask_complete` is only valid during an `implement_task` workflow.")
            
        if subtask_id not in active_tool.completed_subtasks:
            active_tool.completed_subtasks.append(subtask_id)
            state_manager.save_tool_state(task_id, active_tool) # Checkpoint progress
            logger.info(f"Subtask '{subtask_id}' for task '{task_id}' marked as complete.")
            return ToolResponse(status="success", message=f"Acknowledged: Subtask '{subtask_id}' is complete.")
        else:
            return ToolResponse(status="success", message=f"Acknowledged: Subtask '{subtask_id}' was already complete.")

    def submit_implementation_impl(task_id: str, artifact: dict) -> ToolResponse:
        active_tool = orchestrator.active_tools.get(task_id)
        if not active_tool or active_tool.state != "implementing":
             return ToolResponse(status="error", message=f"Cannot submit implementation from current state '{getattr(active_tool, 'state', 'N/A')}'.")
        
        return submit_work_impl(task_id, artifact, trigger_override="submit_implementation")
    ```

2.  **`src/alfred_new/tools/submit_work.py` (MODIFY):**
    *   Ensure the `submit_work_impl` function accepts an optional `trigger_override` argument.

    ```python
    # In submit_work_impl function signature
    def submit_work_impl(task_id: str, artifact: dict, trigger_override: str = None) -> ToolResponse:
        # ...
        # In trigger calculation section
        current_state_val = active_tool.state.value if hasattr(active_tool.state, 'value') else active_tool.state
        trigger = trigger_override or f"submit_{current_state_val}"
        # ...
    ```

#### **Acceptance Criteria:**
*   The `tools/progress.py` file is created with the correct logic.
*   The tools correctly interact with the active `ImplementTaskTool` instance and the state manager.

---
### **TASK: AL-27 (Corrected)**

#### **Title:**
Tools: Implement Main `implement_task` Entry Point Logic

#### **Context:**
This task creates the primary entry point logic for the `implement_task` tool. It handles tool recovery/creation, loads the `ExecutionPlan`, and dispatches the initial "Fire-and-Delegate" prompt.

#### **Implementation Details:**
Create the `tools/implement_task.py` file and its `_impl` function.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/tools/implement_task.py` (NEW FILE):**
    ```python
    # src/alfred_new/tools/implement_task.py
    from src.alfred_new.models.schemas import ToolResponse, TaskStatus
    from src.alfred_new.lib.task_utils import load_task, update_task_status
    from src.alfred_new.lib.artifact_manager import artifact_manager
    from src.alfred_new.orchestration.orchestrator import orchestrator
    from src.alfred_new.orchestration.persona_loader import load_persona
    from src.alfred_new.core.workflow import ImplementTaskTool
    from src.alfred_new.state.recovery import ToolRecovery
    from src.alfred_new.state.manager import state_manager
    from src.alfred_new.core.prompter import prompter
    from src.alfred_new.lib.logger import get_logger

    logger = get_logger(__name__)

    async def implement_task_impl(task_id: str) -> ToolResponse:
        # Boilerplate for tool recovery/creation
        if task_id in orchestrator.active_tools:
            tool_instance = orchestrator.active_tools[task_id]
        else:
            tool_instance = ToolRecovery.recover_tool(task_id)
            if not tool_instance:
                task = load_task(task_id)
                if not task:
                    return ToolResponse(status="error", message=f"Task '{task_id}' not found.")
                if task.task_status != TaskStatus.READY_FOR_DEVELOPMENT:
                    return ToolResponse(status="error", message=f"Task '{task_id}' has status '{task.task_status.value}'. Must be 'ready_for_development'.")
                
                tool_instance = ImplementTaskTool(task_id=task_id)
                update_task_status(task_id, TaskStatus.IN_DEVELOPMENT)
            
            orchestrator.active_tools[task_id] = tool_instance
        
        # Load Execution Plan from the ARCHIVE of the planning phase
        execution_plan_artifact = artifact_manager.read_execution_plan(task_id)
        if not execution_plan_artifact:
            return ToolResponse(status="error", message=f"Execution Plan for task '{task_id}' not found in archive.")
        
        # Store plan in context for prompts and recovery
        tool_instance.context_store['execution_plan'] = execution_plan_artifact
        
        task = load_task(task_id)
        persona_config = load_persona(tool_instance.persona_name)

        next_prompt = prompter.generate_prompt(
            task=task,
            tool_name=tool_instance.tool_name,
            state=tool_instance.state,
            persona_config=persona_config,
            additional_context=tool_instance.context_store
        )
        
        # Dispatch to move state to 'implementing'
        if tool_instance.state == "dispatching":
            tool_instance.dispatch()

        state_manager.save_tool_state(task_id, tool_instance)

        return ToolResponse(
            status="success",
            message="Implementation initiated. The full execution plan has been dispatched.",
            next_prompt=next_prompt
        )
    ```

#### **Acceptance Criteria:**
*   The `implement_task_impl` function correctly recovers or creates an `ImplementTaskTool`.
*   It loads the `execution_plan.json` and places it in the `context_store`.
*   It generates the `dispatching` prompt and transitions the state.

---
### **TASK: AL-28 (Corrected)**

#### **Title:**
Prompts: Create `implement_task` Prompt Templates

#### **Context:**
This task creates the Jinja2 prompt templates that define the AI's instructions for the implementation phase.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/templates/prompts/implement_task/` (NEW DIRECTORY)**
2.  **`src/alfred_new/templates/prompts/implement_task/dispatching.md` (NEW FILE):**
    *   *Content will be the detailed "Fire-and-Delegate" prompt, referencing `subtasks` from `additional_context.execution_plan.subtasks`.*
3.  **`src/alfred_new/templates/prompts/implement_task/reviewing_manifest.md` (NEW FILE):**
    *   *Content will be the manifest review prompt, comparing the `implementing_artifact` to the `execution_plan`.*

#### **Acceptance Criteria:**
*   The new directory and `.md` files exist with the correct, detailed content as designed in our previous session.

---
### **TASK: AL-29 (Corrected)**

#### **Title:**
System: Register All New Implementation Tools

#### **Context:**
This task integrates the newly created tools into the MCP server and the state recovery system, making them live and usable.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/server.py` (MODIFY):**
    *   Add new imports for `implement_task_impl`, `mark_subtask_complete_impl`, `submit_implementation_impl`.
    *   Create the three new `@app.tool()` decorated functions (`implement_task`, `mark_subtask_complete`, `submit_implementation`) with their full docstrings.

2.  **`src/alfred_new/state/recovery.py` (MODIFY):**
    *   Add `from src.alfred_new.core.workflow import ImplementTaskTool`.
    *   Add `'implement_task': ImplementTaskTool` to the `TOOL_REGISTRY` dictionary.

#### **Acceptance Criteria:**
*   The three new tools are exposed and documented on the MCP server.
*   The `ImplementTaskTool` can be recovered from a crash.

---
### **TASK: AL-30 (Corrected)**

#### **Title:**
Retrofit `plan_task`: Enforce `mark_subtask_complete` Reporting

#### **Context:**
This critical retroactive fix ensures that plans generated by `plan_task` are compatible with our new "Tracked Delegation" model.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/templates/prompts/plan_task/generate_slots.md` (MODIFY):**
    *   Update this file to use "Subtask" instead of "SLOT".
    *   Add the "CRITICAL REPORTING PROTOCOL" directive, instructing the AI to add the `mark_subtask_complete` call as the final step in every subtask's `specification`.

#### **Acceptance Criteria:**
*   The `generate_slots.md` prompt is updated. When `plan_task` is run, the generated `ExecutionPlan`'s `subtasks` now all contain the required reporting call.

---
### **Execution & Parallelization Strategy**

*   **Sequential Block 1 (Core Models & Logic):**
    *   `AL-24` -> `AL-25`
*   **Parallel Block 2 (Can be done concurrently after Block 1):**
    *   `AL-26` (Supporting Tools)
    *   `AL-27` (Main Tool Logic)
    *   `AL-28` (Prompts)
    *   `AL-30` (Retrofit `plan_task` prompt)
*   **Sequential Block 3 (Final Integration):**
    *   `AL-29` (Registration) - Must be done after all `_impl` functions are created.
