### **TASK: AL-04**

#### **Title:**
Architectural Core: Implement the `Prompter` Engine

#### **Context:**
With our data models (`Task`, `SLOT`) and the `PlanTaskTool` State Machine defined, we now need the engine to generate the conversational prompts for each state. The `Promter` is the heart of Alfred's user experience. It translates the system's internal state into clear, actionable, persona-driven directives for the AI agent. This task involves creating a new, more powerful `Prompter` class that can handle our new structured `Task` context and tool-based workflow. This component will be used by all workflow tools, making it a critical piece of shared infrastructure.

#### **Implementation Details:**
1.  **Refactor the existing `Prompter`:** Locate the existing `Prompter` logic (likely in `src/alfred/execution/prompter.py`). We will create a new, cleaner `Prompter` class in a new location that is more suited to our tool-based architecture.
2.  **Create a new `prompter.py` module.** This will house the new `Prompter` class. It will be the central service for all prompt generation.
3.  **The `generate_prompt` method:** The core method of the `Prompter` class will be `generate_prompt`. This method will accept the following arguments:
    *   `task: Task`: The full, structured `Task` object.
    *   `tool_name: str`: The name of the currently active tool (e.g., `"plan_task"`).
    *   `state: Enum`: The current state from the tool's internal State Machine (e.g., `PlanTaskState.STRATEGIZE`).
    *   `persona_config: dict`: The loaded YAML configuration for the persona associated with the tool.
    *   `additional_context: Optional[dict] = None`: A dictionary for any other ad-hoc data, such as review feedback.
4.  **Dynamic Template Path Resolution:** The `generate_prompt` method will be responsible for constructing the correct path to the `.md` template file. The path will be dynamically generated based on the tool name and state, following a new, standardized convention: `templates/prompts/{tool_name}/{state_name}.md`. For example, `templates/prompts/plan_task/strategize.md`.
5.  **Jinja2 Rendering:** The method will use Jinja2 to render the template, passing a comprehensive context object containing the `task`, `persona_config`, and any `additional_context`. This ensures the prompts are rich with all necessary information.
6.  **Code Reuse:** We will move and reuse the Jinja2 environment setup logic from the old `ArtifactManager` or `Prompter` into this new, centralized class. The `ArtifactManager` should no longer be responsible for rendering prompts.

**Dev Notes:**
*   This is a critical refactoring task. We are centralizing all prompt generation logic into one reusable class.
*   The `ArtifactManager`'s responsibility will be limited to file I/O (reading/writing artifacts like `execution_plan.json` and the scratchpad). We must decouple it from prompt generation.
*   The new `Prompter` must be stateless. It should not hold any session data; all required information is passed into the `generate_prompt` method on each call.

**Files to Modify/Create:**

1.  **`src/alfred/core/prompter.py` (NEW FILE):**
    ```python
    # src/alfred/core/prompter.py
    from jinja2 import Environment, FileSystemLoader
    from pathlib import Path
    from enum import Enum
    from typing import Dict, Any, Optional

    from src.alfred.config.settings import settings # Reuse existing settings
    from src.alfred.models.schemas import Task # Reuse our new Task model

    class Prompter:
        """Generates persona-driven, state-aware prompts for the AI agent."""

        def __init__(self):
            # Reuse existing settings to find the templates directory
            search_path = settings.alfred_dir / "templates"
            if not search_path.exists():
                # Fallback to packaged templates if user hasn't initialized
                search_path = settings.packaged_templates_dir

            self.template_loader = FileSystemLoader(searchpath=str(search_path))
            self.jinja_env = Environment(loader=self.template_loader, trim_blocks=True, lstrip_blocks=True)

        def generate_prompt(
            self,
            task: Task,
            tool_name: str,
            state: Enum,
            persona_config: Dict[str, Any],
            additional_context: Optional[Dict[str, Any]] = None
        ) -> str:
            """
            Generates a prompt by rendering a template with the given context.

            Args:
                task: The full structured Task object.
                tool_name: The name of the active tool (e.g., 'plan_task').
                state: The current state from the tool's SM.
                persona_config: The loaded YAML config for the tool's persona.
                additional_context: Ad-hoc data like review feedback.

            Returns:
                The rendered prompt string.
            """
            template_path = f"prompts/{tool_name}/{state.value}.md"
            
            try:
                template = self.jinja_env.get_template(template_path)
            except Exception as e:
                # Proper error handling is crucial
                error_message = f"CRITICAL ERROR: Prompt template not found at '{template_path}'. Details: {e}"
                print(error_message) # Or use logger
                return error_message

            # Build the comprehensive context for the template
            render_context = {
                "task": task,
                "tool_name": tool_name,
                "state": state.value,
                "persona": persona_config,
                **(additional_context or {})
            }

            return template.render(render_context)

    # Singleton instance to be used across the application
    prompter = Prompter()
    ```

2.  **`src/alfred/lib/artifact_manager.py` (REFACTOR):**
    *   Locate the existing `ArtifactManager`.
    *   **Remove** any Jinja2 environment setup and template rendering logic from this file. Its sole responsibility is now file system I/O for artifacts.
    *   The `append_to_scratchpad` method might need to be simplified or refactored if it was previously handling prompt rendering. It should now just write pre-formatted content.

#### **Acceptance Criteria:**
*   A new file `src/alfred/core/prompter.py` exists with the `Prompter` class as specified.
*   The `Prompter` class correctly initializes a Jinja2 environment pointing to the templates directory.
*   The `generate_prompt` method correctly constructs the template path based on `tool_name` and `state`.
*   The `generate_prompt` method successfully renders a template when provided with a valid `Task` object and other context.
*   Prompt generation logic has been removed from `ArtifactManager`.

#### **AC Verification:**
*   Create a dummy `Task` object.
*   Create a dummy persona config dictionary.
*   Create a dummy template file at `templates/prompts/plan_task/strategize.md` that uses variables like `{{ task.title }}` and `{{ persona.name }}`.
*   Call `prompter.generate_prompt(...)` with the dummy data and the `PlanTaskState.STRATEGIZE` enum.
*   Assert that the returned string is the correctly rendered template with the `task.title` and `persona.name` values injected.
*   Assert that calling `generate_prompt` for a non-existent template path returns a clear error message.

#### **Unit Tests:**
*   Create a new test file `tests/core/test_prompter.py`.
*   Use `unittest.mock` to patch `FileSystemLoader` to point to a temporary test templates directory.
*   Write a test `test_successful_prompt_generation` that sets up a dummy template and asserts that `generate_prompt` renders it correctly.
*   Write a test `test_context_injection` to confirm that all parts of the `task`, `persona`, and `additional_context` are available within the template.
*   Write a test `test_template_not_found_error` to ensure a meaningful error string is returned when the template path is invalid.
