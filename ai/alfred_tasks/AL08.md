### **Implementation Directive: AL-08 (Revised) - Implement Interactive `start_task` Workflow**

**Objective:** Transform `start_task` into a stateful, interactive workflow tool that handles Git branch setup and task confirmation through a guided, conversational process, culminating in a mandatory review.

**Executor's Action:** Instruct the agent to create or replace the specified files with the exact content provided.

#### **1. Define New Models in `src/alfred/models/planning_artifacts.py`**
Add the artifact models required for the `start_task` workflow.

```python
# In src/alfred/models/planning_artifacts.py, add the following classes:

class GitStatusArtifact(BaseModel):
    is_clean: bool
    current_branch: str
    uncommitted_files: List[str]


class BranchCreationArtifact(BaseModel):
    branch_name: str
    success: bool
    details: str
```

#### **2. Create `src/alfred/personas/onboarding.yml`**
Create a new persona for this tool.

```yaml
# src/alfred/personas/onboarding.yml
name: "Alfred"
title: "Personal Butler & Project Lead"

greeting: "Good day. I am Alfred, at your service. Before we proceed with the task, we must ensure our workspace is in perfect order. Let's begin."

communication_style: "Polite, professional, and precise. I guide the user through necessary setup procedures with clear, step-by-step instructions. I anticipate needs but always await confirmation before taking action."

thinking_methodology:
  - "A clean workspace is the foundation of quality work. First, we establish order."
  - "Verify, then act. Never proceed on assumptions."
  - "Guide the user clearly, presenting them with both the current status and the proposed next action."
```

#### **3. Define the Workflow in `src/alfred/core/workflow.py`**
Add the new `StartTaskTool` and its state definitions.

```python
# In src/alfred/core/workflow.py, add the following:

from .models.planning_artifacts import GitStatusArtifact, BranchCreationArtifact # Add these imports

class StartTaskState(str, Enum):
    """States for the StartTaskTool's internal State Machine."""
    INITIALIZED = "initialized"
    GIT_STATUS_CHECKED = "git_status_checked"
    BRANCH_CREATED = "branch_created"
    VERIFIED = "verified"


class StartTaskTool(BaseWorkflowTool):
    """Encapsulates the state and logic for the `start_task` command."""

    def __init__(self, task_id: str, persona_name: str = "onboarding"):
        super().__init__(
            task_id, tool_name=ToolName.START_TASK, persona_name=persona_name
        )

        self.artifact_map = {
            StartTaskState.GIT_STATUS_CHECKED: GitStatusArtifact,
            StartTaskState.BRANCH_CREATED: BranchCreationArtifact,
        }

        states = [state.value for state in StartTaskState] + [
            state.value for state in ReviewState
        ]

        transitions = [
            # The tool starts, prompts for Git status check
            {"trigger": "check_git_status", "source": StartTaskState.INITIALIZED, "dest": StartTaskState.GIT_STATUS_CHECKED},
            # User submits Git status, tool proposes action, enters review
            *self._create_review_transitions(StartTaskState.GIT_STATUS_CHECKED, StartTaskState.BRANCH_CREATED),
            # After approval, user submits branch creation result, enters final review
            *self._create_review_transitions(StartTaskState.BRANCH_CREATED, StartTaskState.VERIFIED),
        ]

        self.machine = Machine(
            model=self,
            states=states,
            transitions=transitions,
            initial=StartTaskState.INITIALIZED.value,
        )
```

#### **4. Create Prompts for `start_task`**
Create a new directory and the required prompt template files.

**Directory:** `src/alfred/templates/prompts/start_task/`

**File:** `src/alfred/templates/prompts/start_task/initialized.md`
```markdown
# ROLE: {{ persona.name }}, {{ persona.title }}
# TOOL: `alfred.start_task`
# TASK: {{ task.task_id }} - {{ task.title }}
# STATE: initialized

{{ persona.greeting }}

My first responsibility is to ensure your Git repository is clean and on the correct branch.

---
### **Directive: Check Git Status**

Please execute the following commands in your terminal and report the results:
1.  `git status --porcelain` (to check for uncommitted changes)
2.  `git rev-parse --abbrev-ref HEAD` (to get the current branch name)

---
### **Required Action**

You MUST now call `alfred.submit_work` with a `GitStatusArtifact`.

**Required Artifact Structure:**
```json
{
  "is_clean": "boolean - True if 'git status --porcelain' has NO output, otherwise False.",
  "current_branch": "string - The output of 'git rev-parse --abbrev-ref HEAD'.",
  "uncommitted_files": ["string - A list of files reported by 'git status --porcelain', if any."]
}
```
```

**File:** `src/alfred/templates/prompts/start_task/git_status_checked.md`
```markdown
# ROLE: {{ persona.name }}, {{ persona.title }}
# TOOL: `alfred.start_task`
# TASK: {{ task.task_id }}
# STATE: git_status_checked

Thank you. I have reviewed the status of your repository. Based on your report, I will propose the correct course of action. Please review my proposal and confirm before I proceed.

---
### **Directive: Propose Git Action**

My analysis of your repository status is complete. My proposed action is to create a new branch named `feature/{{ task.task_id }}`. This will ensure your work is properly isolated.

*This is a proposal. No action has been taken yet.*

---
### **Required Action**

This step requires both an AI and a Human review to ensure safety.

First, as an AI, please verify that my proposal is sound. Call `alfred.provide_review` with `is_approved=True`.

After you approve, I will prompt for human confirmation.
```

**File:** `src/alfred/templates/prompts/start_task/branch_created.md`
```markdown
# ROLE: {{ persona.name }}, {{ persona.title }}
# TOOL: `alfred.start_task`
# TASK: {{ task.task_id }}
# STATE: branch_created

Excellent. The human operator has approved the action.

---
### **Directive: Create and Verify Branch**

Please execute the proposed git command to create and switch to the new feature branch:
`git checkout -b feature/{{ task.task_id }}`

If the branch already exists, use `git checkout feature/{{ task.task_id }}` instead.

After executing the command, please report the outcome.

---
### **Required Action**

You MUST now call `alfred.submit_work` with a `BranchCreationArtifact`.

**Required Artifact Structure:**
```json
{
  "branch_name": "string - The name of the new branch, 'feature/{{ task.task_id }}'.",
  "success": "boolean - True if the command executed without errors.",
  "details": "string - The output from the git command."
}
```
```

#### **5. Update `ToolRecovery`**
Register the new `StartTaskTool` for state recovery.

```python
# In src/alfred/state/recovery.py

from src.alfred.core.workflow import BaseWorkflowTool, PlanTaskTool, StartTaskTool # Add StartTaskTool
# ...

class ToolRecovery:
    TOOL_REGISTRY: Dict[str, Type[BaseWorkflowTool]] = {
        ToolName.START_TASK: StartTaskTool, # ADD THIS LINE
        ToolName.PLAN_TASK: PlanTaskTool,
    }
    # ... rest of the file is unchanged
```

#### **6. Refactor `src/alfred/tools/start_task.py`**
Replace the simple utility function with a full-fledged tool controller.

```python
# src/alfred/tools/start_task.py
"""
The start_task tool, re-architected as a stateful workflow tool.
"""
from src.alfred.core.prompter import prompter
from src.alfred.core.workflow import StartTaskTool
from src.alfred.lib.logger import get_logger, setup_task_logging
from src.alfred.lib.task_utils import load_task
from src.alfred.models.schemas import TaskStatus, ToolResponse
from src.alfred.orchestration.orchestrator import orchestrator
from src.alfred.orchestration.persona_loader import load_persona
from src.alfred.state.manager import state_manager
from src.alfred.state.recovery import ToolRecovery

logger = get_logger(__name__)


def start_task_impl(task_id: str) -> ToolResponse:
    """Implementation logic for the interactive start_task tool."""
    setup_task_logging(task_id)

    task = load_task(task_id)
    if not task:
        return ToolResponse(status="error", message=f"Task '{task_id}' not found.")

    if task_id in orchestrator.active_tools:
        tool_instance = orchestrator.active_tools[task_id]
        logger.info(f"Found active tool for task {task_id} in state {tool_instance.state}")
    else:
        tool_instance = ToolRecovery.recover_tool(task_id)
        if tool_instance:
            orchestrator.active_tools[task_id] = tool_instance
            logger.info(f"Recovered tool for task {task_id} in state {tool_instance.state}")
        else:
            if task.task_status not in [TaskStatus.NEW, TaskStatus.PLANNING]:
                return ToolResponse(
                    status="error",
                    message=f"Task '{task_id}' has status '{task.task_status.value}'. Setup can only start on a 'new' task.",
                )

            tool_instance = StartTaskTool(task_id=task_id)
            orchestrator.active_tools[task_id] = tool_instance
            state_manager.update_tool_state(task_id, tool_instance)
            logger.info(f"Created new start_task tool for task {task_id}")

    try:
        persona_config = load_persona(tool_instance.persona_name)
    except FileNotFoundError as e:
        return ToolResponse(status="error", message=str(e))

    prompt = prompter.generate_prompt(
        task=task,
        tool_name=tool_instance.tool_name,
        state=tool_instance.state,
        persona_config=persona_config,
    )

    message = f"Starting setup for task '{task_id}'. Current step: {tool_instance.state}."

    return ToolResponse(status="success", message=message, next_prompt=prompt)
```

#### **7. Update `provide_review.py` for `start_task` Completion**
The `provide_review` tool needs to know what to do when `start_task` finishes.

```python
# In src/alfred/tools/provide_review.py, modify the terminal state handling:

# ... inside provide_review_impl, in the `if active_tool.is_terminal:` block

    if active_tool.is_terminal:
        # --- ADD THIS LOGIC ---
        if active_tool.tool_name == ToolName.START_TASK:
            final_task_status = TaskStatus.PLANNING
            handoff_message = f"Setup for task {task_id} is complete. The task is now '{final_task_status.value}'. Call 'plan_task' to begin planning."
        # --- END ADDED LOGIC ---
        elif active_tool.tool_name == ToolName.PLAN_TASK:
            final_task_status = TaskStatus.READY_FOR_DEVELOPMENT
            handoff_message = f"Planning for task {task_id} is complete. The task is now '{final_task_status.value}'. To begin implementation, use the 'implement_task' tool."
        else:
            final_task_status = TaskStatus.DONE # Default fallback
            handoff_message = f"Tool '{active_tool.tool_name}' for task {task_id} completed."

        state_manager.update_task_status(task_id, final_task_status)
        state_manager.clear_tool_state(task_id)
        del orchestrator.active_tools[task_id]
        cleanup_task_logging(task_id)
        logger.info(f"Tool '{active_tool.tool_name}' for task {task_id} completed. Task status updated to '{final_task_status.value}'.")
        
        return ToolResponse(status="success", message=message, next_prompt=handoff_message)
# ... rest of the function
```

#### **Acceptance Criteria & Verification Steps:**

This is a script for manual end-to-end testing. You will guide the agent to perform these steps after the implementation is complete.

**Setup:**
1.  Ensure the MCP server is running.
2.  Use a test task, e.g., `TS-01`.
3.  **Delete** the directory `.alfred/workspace/TS-01` to ensure a clean slate.

**Verification Flow:**

1.  **Initiate the tool:**
    *   **Action:** Call `start_task(task_id="TS-01")`.
    *   **Assert:** The `next_prompt` in the response must contain the text "Directive: Check Git Status" and ask for the output of `git status --porcelain` and `git rev-parse --abbrev-ref HEAD`.
    *   **Inspect:** The file `.alfred/workspace/TS-01/task_state.json` must exist. Its `active_tool_state.current_state` must be `"initialized"`.

2.  **Submit Git Status (Clean State):**
    *   **Action:** Call `submit_work(task_id="TS-01", artifact={"is_clean": True, "current_branch": "main", "uncommitted_files": []})`.
    *   **Assert:** The `next_prompt` must contain "STATE: awaiting_ai_review".
    *   **Inspect:** The `task_state.json` file's `active_tool_state.current_state` must now be `"awaiting_ai_review"`.

3.  **AI Approves Git Status:**
    *   **Action:** Call `provide_review(task_id="TS-01", is_approved=True)`.
    *   **Assert:** The `next_prompt` must contain "STATE: awaiting_human_review".
    *   **Inspect:** The `task_state.json` file's `active_tool_state.current_state` must now be `"awaiting_human_review"`.

4.  **Human Approves Git Action:**
    *   **Action:** Call `provide_review(task_id="TS-01", is_approved=True)`.
    *   **Assert:** The `next_prompt` must contain "Directive: Create and Verify Branch" and instruct the user to execute `git checkout -b feature/TS-01`.
    *   **Inspect:** The `task_state.json` file's `active_tool_state.current_state` must now be `"branch_created"`.

5.  **Submit Branch Creation Result:**
    *   **Action:** Call `submit_work(task_id="TS-01", artifact={"branch_name": "feature/TS-01", "success": True, "details": "Switched to a new branch 'feature/TS-01'"})`.
    *   **Assert:** The `next_prompt` must again be for `awaiting_ai_review`.
    *   **Inspect:** The `task_state.json` file's `active_tool_state.current_state` must be `"awaiting_ai_review"`.

6.  **Final AI Approval:**
    *   **Action:** Call `provide_review(task_id="TS-01", is_approved=True)`.
    *   **Inspect:** The `task_state.json` file's `active_tool_state.current_state` must be `"awaiting_human_review"`.

7.  **Final Human Approval & Tool Completion:**
    *   **Action:** Call `provide_review(task_id="TS-01", is_approved=True)`.
    *   **Assert:** The `next_prompt` in the response must contain the handoff message: "Setup for task TS-01 is complete. The task is now 'planning'. Call 'plan_task' to begin planning."
    *   **Inspect:** The `task_state.json` file must now have:
        *   `task_status` set to `"planning"`.
        *   `active_tool_state` set to `null`.
    *   **Assert:** The `start_task` tool is no longer in the `orchestrator.active_tools` dictionary in memory.
