
### **Implementation Directive: AL-04 - Implement `start_task` Tool**

**Objective:** Create the `start_task` tool, the formal entry point for a task, responsible for bootstrapping the workspace and initial state.

**Executor's Action:** Instruct the agent to create or replace the following files with the exact content provided.

#### **1. Modify `src/alfred/constants.py`:**
Add the `START_TASK` tool name to the `ToolName` class.

```python
# src/alfred/constants.py
"""
Central constants and configuration values for Alfred.
...
"""
from enum import Enum
from typing import Final


# Tool Names
class ToolName:
    """Tool name constants."""

    START_TASK: Final[str] = "start_task" # ADD THIS LINE
    PLAN_TASK: Final[str] = "plan_task"
    IMPLEMENT_TASK: Final[str] = "implement_task"

# ... (rest of the file remains unchanged)
```

#### **2. Create `src/alfred/tools/start_task.py`:**
This file contains the core logic for the new tool.

```python
# src/alfred/tools/start_task.py
"""
The start_task tool, responsible for bootstrapping a task's workspace.
"""
from pathlib import Path

from src.alfred.lib.logger import get_logger, setup_task_logging
from src.alfred.lib.task_utils import load_task
from src.alfred.models.schemas import TaskStatus, ToolResponse
from src.alfred.state.manager import state_manager

logger = get_logger(__name__)


def start_task_impl(task_id: str, root_dir: Path | None = None) -> ToolResponse:
    """
    Initializes the workspace and state for a new or existing task.

    This tool is the formal entry point for any task. It:
    1. Sets up task-specific logging.
    2. Verifies the task exists by loading its definition.
    3. Creates the task's workspace directory if it doesn't exist.
    4. Loads or creates the unified state file for the task.
    5. Sets the task status to 'PLANNING' if it's a new task.
    6. Returns a success message guiding the user to the next step.
    """
    setup_task_logging(task_id)
    logger.info(f"Initiating start_task for task: {task_id}")

    # Verify task definition exists
    task = load_task(task_id, root_dir)
    if not task:
        logger.error(f"Task definition not found for task_id: {task_id}")
        return ToolResponse(
            status="error",
            message=f"Task '{task_id}' not found. Ensure a task definition file exists at '.alfred/tasks/{task_id}.md'.",
        )

    # Load or create the unified state, which also creates the workspace dir
    state = state_manager.load_or_create_task_state(task_id)

    # Check if we need to update the status
    if state.task_status == TaskStatus.NEW:
        logger.info(
            f"Task {task_id} is new. Transitioning status to PLANNING."
        )
        state_manager.update_task_status(task_id, TaskStatus.PLANNING)
        message = (
            f"Workspace for new task '{task_id}' initialized successfully. "
            "Task status set to PLANNING."
        )
    else:
        logger.info(
            f"Resuming task '{task_id}' with existing status: {state.task_status.value}."
        )
        message = (
            f"Workspace for existing task '{task_id}' is ready. "
            f"Current status is '{state.task_status.value}'."
        )

    next_prompt = f"The task '{task_id}' is ready for planning. Call the 'plan_task' tool to begin."
    return ToolResponse(
        status="success", message=message, next_prompt=next_prompt
    )

```

#### **3. Modify `src/alfred/server.py`:**
Register the new `start_task` tool with the FastMCP server.

```python
# src/alfred/server.py
"""
MCP Server for Alfred
"""

import inspect

from fastmcp import FastMCP

from src.alfred.config.settings import settings
from src.alfred.lib.transaction_logger import transaction_logger
from src.alfred.models.schemas import ToolResponse
from src.alfred.tools.initialize import initialize_project as initialize_project_impl
from src.alfred.tools.plan_task import plan_task_impl
from src.alfred.tools.progress import mark_subtask_complete_impl
# --- ADD THIS IMPORT ---
from src.alfred.tools.start_task import start_task_impl
from src.alfred.tools.provide_review import provide_review_impl
from src.alfred.tools.submit_work import submit_work_impl

app = FastMCP(settings.server_name)


@app.tool()
async def initialize_project(provider: str | None = None) -> ToolResponse:
    # ... (function content remains unchanged)
    # ...
    response = initialize_project_impl(provider)
    transaction_logger.log(
        task_id=None, tool_name=tool_name, request_data=request_data, response=response
    )
    return response


# --- ADD THE NEW TOOL DEFINITION ---
@app.tool()
async def start_task(task_id: str) -> ToolResponse:
    """
    Initializes the workspace for a specific task, making it ready for planning.

    This is the first command to run for any given task. It sets up the necessary
    directory structure and state files. If the task is new, its status will be
    set to 'planning'. If the task already exists, it simply ensures the workspace
    is ready for the next command.

    Args:
        task_id (str): The unique identifier for the task (e.g., "TS-01").

    Returns:
        ToolResponse: Contains success/error status and a prompt guiding the user to call 'plan_task'.
    """
    tool_name = inspect.currentframe().f_code.co_name
    request_data = {"task_id": task_id}

    response = start_task_impl(task_id)
    transaction_logger.log(
        task_id=task_id,
        tool_name=tool_name,
        request_data=request_data,
        response=response,
    )
    return response


@app.tool()
async def plan_task(task_id: str) -> ToolResponse:
    # ... (function content remains unchanged)
    # ...
    response = await plan_task_impl(task_id)
    transaction_logger.log(
        task_id=task_id,
        tool_name=tool_name,
        request_data=request_data,
        response=response,
    )
    return response

# ... (rest of the file remains unchanged)
```