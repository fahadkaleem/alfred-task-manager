### **The Definitive "Markdown-First" Architecture**

1.  **Single Source of Truth:** The `.alfred/tasks/TS-01.md` file is the **one and only** source of truth for a task's definition. There will be no `task.json` file in the workspace for the definition itself.
2.  **State Lives Separately:** The dynamic, operational state of a task (e.g., its `task_status`, the active tool, the internal SM state) will live in a separate, simple state file: `.alfred/workspace/TS-01/state.json`. This is critical. We are decoupling the **static definition** of a task from its **dynamic state**.
3.  **Parsing at the Boundary:** When a tool like `plan_task` is called, its first action is to:
    a. Read the `.alfred/tasks/TS-01.md` file.
    b. Call a `MarkdownTaskParser` utility to parse the content into our Pydantic `Task` object in memory.
    c. Load the separate `state.json` to get the current `task_status`.
    This gives us the complete, in-memory representation of the task to work with.
4.  **Saving State, Not Definition:** When a tool completes or changes the high-level status, it will only write to the `.alfred/workspace/TS-01/state.json` file. The original `.md` definition remains untouched unless explicitly modified by a future "edit task" tool.

This is a clean, robust, and professional architecture. It perfectly separates the human-editable definition from the machine-managed state.

---
### **The Path Forward: Building the Markdown Parser**

We cannot proceed with testing `plan_task` until we build this critical bridge. The next task is to create the Markdown parser and update our `load_task` utility to use it.

This task is now the highest priority. Provide this to your development AI.

---
### **TASK: AL-19**

#### **Title:**
Core Infrastructure: Implement Markdown Task Parser

#### **Context:**
We have adopted a "Markdown-First" architecture for task definitions to ensure they are human-readable and easy to author. We now need the core utility to parse these `.md` files into our internal, Pydantic-validated `Task` objects. This task involves creating a `MarkdownTaskParser` and integrating it into our `task_utils.py` library. This is the critical bridge that connects our human-friendly task files to our robust, type-safe internal system.

#### **Implementation Details:**
1.  **Create a `MarkdownTaskParser` class.** This class will live in a new file, `src/alfred/lib/md_parser.py`. Its primary method will be `parse(markdown_content: str) -> dict`.
2.  **Implement the parsing logic.** The `parse` method will use regular expressions to find the content under each specific heading (`## Title`, `## Context`, `## Acceptance Criteria`, etc.) in the Markdown string. It will handle multi-line content for each section.
    *   For list-based sections (`Acceptance Criteria`, `Dependencies`), it should parse lines starting with `- ` into a list of strings.
3.  **Refactor `load_task` in `task_utils.py`.** This function must be completely rewritten. It will no longer look for `task.json`. Instead, it will:
    a. Construct the path to `.alfred/tasks/{task_id}.md`.
    b. Read the content of the `.md` file.
    c. Instantiate the `MarkdownTaskParser` and call its `parse` method to get a dictionary of the task data.
    d. Instantiate the Pydantic `Task` model from the parsed dictionary (`Task(**parsed_data)`).
    e. Load the separate `.alfred/workspace/{task_id}/state.json` file to get the current `task_status` and overwrite the default status on the in-memory `Task` object.
    f. Return the complete, state-aware `Task` object.
4.  **Refactor `save_task` to `save_task_state`.** The `save_task` function is now misnamed. Rename it to `save_task_state`. It will no longer save the full `Task` object. It will only save a small `State` object (e.g., `{"task_status": "planning"}`) to `.alfred/workspace/{task_id}/state.json`.

**Dev Notes:**
*   The regex for parsing should be robust enough to handle empty sections and optional sections like `## Dev Notes`.
*   A section is defined as the heading (e.g., `## Context`) and all content that follows until the next `## ` heading or the end of the file.
*   This refactoring fundamentally separates the static task definition from its dynamic state, which is a major architectural improvement.

**Files to Modify/Create:**

1.  **`src/alfred/lib/md_parser.py` (NEW FILE):**
    ```python
    # src/alfred/lib/md_parser.py
    import re
    from typing import Dict, List

    class MarkdownTaskParser:
        """Parses a task definition from a markdown string."""

        def parse(self, markdown_content: str) -> Dict:
            """Parses the markdown content into a dictionary."""
            data = {}
            # Extract the task_id from the first line, e.g., '# TASK: TS-01'
            task_id_match = re.search(r"^#\s*TASK:\s*(\S+)", markdown_content)
            if task_id_match:
                data['task_id'] = task_id_match.group(1).strip()

            sections = {
                "title": r"##\s*Title\s*\n(.*?)(?=\n##|$)",
                "priority": r"##\s*Priority\s*\n(.*?)(?=\n##|$)",
                "context": r"##\s*Context\s*\n(.*?)(?=\n##|$)",
                "implementation_details": r"##\s*Implementation Details\s*\n(.*?)(?=\n##|$)",
                "dev_notes": r"##\s*Dev Notes\s*\n(.*?)(?=\n##|$)",
            }

            for key, pattern in sections.items():
                match = re.search(pattern, markdown_content, re.DOTALL | re.IGNORECASE)
                if match:
                    data[key] = match.group(1).strip()

            # Parse list-based sections
            list_sections = {
                "dependencies": r"##\s*Dependencies\s*\n(.*?)(?=\n##|$)",
                "acceptance_criteria": r"##\s*Acceptance Criteria\s*\n(.*?)(?=\n##|$)",
                "ac_verification_steps": r"##\s*AC Verification\s*\n(.*?)(?=\n##|$)",
            }

            for key, pattern in list_sections.items():
                match = re.search(pattern, markdown_content, re.DOTALL | re.IGNORECASE)
                if match:
                    content = match.group(1).strip()
                    # Split lines and strip '- ' prefix
                    data[key] = [re.sub(r"^\s*-\s*", "", line).strip() for line in content.split('\n') if line.strip()]
                
            return data
    ```

2.  **`src/alfred/lib/task_utils.py` (REFACTOR):**
    ```python
    # src/alfred/lib/task_utils.py
    # ... imports ...
    from .md_parser import MarkdownTaskParser
    
    def load_task(task_id: str, root_dir: Optional[Path] = None) -> Task | None:
        """Loads a Task by parsing its .md file and merging with its state.json."""
        alfred_dir = root_dir or settings.alfred_dir
        task_md_path = alfred_dir / "tasks" / f"{task_id}.md"

        if not task_md_path.exists():
            return None

        # Parse the markdown definition
        parser = MarkdownTaskParser()
        task_data = parser.parse(task_md_path.read_text())
        task_model = Task(**task_data)

        # Load the dynamic state
        state_file = alfred_dir / "workspace" / task_id / "state.json"
        if state_file.exists():
            state_data = json.loads(state_file.read_text())
            # Update the model with the persisted state
            task_model.task_status = TaskStatus(state_data.get("task_status", "new"))
        
        return task_model

    def save_task_state(task_id: str, status: TaskStatus, root_dir: Optional[Path] = None):
        """Saves only the dynamic state of a task."""
        alfred_dir = root_dir or settings.alfred_dir
        state_dir = alfred_dir / "workspace" / task_id
        state_dir.mkdir(parents=True, exist_ok=True)
        state_file = state_dir / "state.json"
        
        state_data = {"task_status": status.value}
        state_file.write_text(json.dumps(state_data, indent=2))
        
    # update_task_status will now use save_task_state
    ```

#### **Acceptance Criteria & AC Verification:**
*   A `MarkdownTaskParser` class exists and can successfully parse the content of `TS-01.md` into a dictionary.
*   The `load_task` function now reads from `.alfred/tasks/*.md`, uses the parser, and correctly returns a Pydantic `Task` object.
*   The `save_task` function is renamed to `save_task_state` and only writes the `task_status` to a `state.json` file.
*   An integration test using the `alfred_test_project` fixture can successfully call `plan_task`, which in turn successfully uses the new `load_task` to parse a test `.md` file.

#### **Unit Tests:**
*   **`tests/lib/test_md_parser.py`:** Create tests for the parser, including a test that parses the full `TS-01.md` content and validates the resulting dictionary.
*   **`tests/lib/test_task_utils.py`:** Rewrite tests for `load_task` to use `.md` files and for `save_task_state` to verify the `state.json` file.