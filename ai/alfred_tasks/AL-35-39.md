The following tasks are the complete, definitive, and highly detailed implementation plan for the `start_task` tool. They are designed to be executed sequentially and contain all necessary code, file paths, and verification criteria. This is the blueprint.

---
### **TASK: AL-35 (Definitive)**

#### **Title:**
Core Models: Implement `StartTask` State Enum and Artifacts

#### **Context:**
This foundational task defines the data structures for the new `start_task` workflow. We will create the `StartTaskState` enum and the `GitSetupArtifact` model. We will reuse the existing `RequirementsArtifact` from the old codebase, ensuring it is present and correct in our new structure.

#### **Implementation Details:**

1.  **Define `StartTaskState` Enum:** In `src/alfred_new/core/workflow.py`, add the new state enum for the `start_task` tool.
2.  **Define `GitSetupArtifact` Model:** In `src/alfred_new/models/planning_artifacts.py`, add the new Pydantic model for the git setup submission.
3.  **Confirm/Move `RequirementsArtifact`:** Ensure the `RequirementsArtifact` model exists in `src/alfred_new/models/planning_artifacts.py`. If it only exists in the old `src/alfred` codebase, copy it over.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/core/workflow.py` (MODIFY):**
    ```python
    # src/alfred_new/core/workflow.py
    from enum import Enum
    
    # ... existing PlanTaskState enum ...
    
    # --- ADD NEW ENUM ---
    class StartTaskState(str, Enum):
        """States for the StartTaskTool's internal State Machine."""
        FETCHING_REQUIREMENTS = "fetching_requirements"
        REVIEWING_REQUIREMENTS = "reviewing_requirements"
        WRITING_TASK_FILE = "writing_task_file"
        PREPARING_GIT = "preparing_git"
        REVIEWING_GIT = "reviewing_git"
        WORKSPACE_READY = "workspace_ready"  # Terminal state
    
    # ... existing BaseWorkflowTool and other Tool classes ...
    ```

2.  **`src/alfred_new/models/planning_artifacts.py` (MODIFY):**
    ```python
    # src/alfred_new/models/planning_artifacts.py
    from pydantic import BaseModel, Field
    from typing import List, Optional
    
    # ... other existing artifact models ...
    
    # --- CONFIRM/ADD THIS MODEL ---
    # This might need to be copied from the old src/alfred/models/artifacts.py
    class RequirementsArtifact(BaseModel):
        task_id: str
        task_summary: str
        task_description: str
        acceptance_criteria: List[str]
        
    # --- ADD NEW MODEL ---
    class GitSetupArtifact(BaseModel):
        branch_name: str = Field(description="The name of the git branch that was checked out.")
        git_status: str = Field(description="The output of the `git status --porcelain` command, indicating cleanliness.")
        is_ready: bool = Field(description="A boolean indicating if the git environment is ready for planning.")
        
    # --- ADD NEW MODEL for the writing_task_file confirmation ---
    class TaskFileCreationArtifact(BaseModel):
        file_path: str = Field(description="The path to the newly created .md task file.")
        status: str = Field(default="created", description="The status of the file creation.")
    ```

#### **Acceptance Criteria:**
*   `StartTaskState` enum is present and correct in `workflow.py`.
*   `RequirementsArtifact`, `GitSetupArtifact`, and `TaskFileCreationArtifact` classes are present and correct in `planning_artifacts.py`.
*   The project code remains valid and passes linting checks.

---
### **TASK: AL-36 (Definitive)**

#### **Title:**
Core Workflow: Create `StartTaskTool` State Machine Class

#### **Context:**
This task defines the core logic and State Machine for the `start_task` workflow. We will create the `StartTaskTool` class, which encapsulates the states, transitions, and artifact mappings for this new, essential phase.

#### **Implementation Details:**
This task involves adding the new `StartTaskTool` class to the `workflow.py` file.

#### **Files to Modify/Create:**

1.  **`src/alfred_new/core/workflow.py` (MODIFY):**
    ```python
    # src/alfred_new/core/workflow.py
    # ... existing imports and classes ...
    from src.alfred_new.models.planning_artifacts import (
        RequirementsArtifact, GitSetupArtifact, TaskFileCreationArtifact
    )
    
    # ... existing enums, BaseWorkflowTool, and other tool classes ...
    
    # --- ADD NEW TOOL CLASS ---
    class StartTaskTool(BaseWorkflowTool):
        """Encapsulates the state and logic for the `start_task` command."""
        def __init__(self, task_id: str, persona_name: str = "setup_specialist"):
            super().__init__(task_id, tool_name="start_task", persona_name=persona_name)
    
            self.artifact_map = {
                StartTaskState.FETCHING_REQUIREMENTS: RequirementsArtifact,
                StartTaskState.WRITING_TASK_FILE: TaskFileCreationArtifact,
                StartTaskState.PREPARING_GIT: GitSetupArtifact,
            }
    
            states = [state.value for state in StartTaskState]
    
            transitions = [
                # Ingestion Phase
                *self._create_review_transitions(
                    source_state=StartTaskState.FETCHING_REQUIREMENTS,
                    review_state=StartTaskState.REVIEWING_REQUIREMENTS,
                    success_destination_state=StartTaskState.WRITING_TASK_FILE
                ),
                # Writing the file is a single step that moves to git setup
                {'trigger': 'submit_writing_task_file', 'source': StartTaskState.WRITING_TASK_FILE, 'dest': StartTaskState.PREPARING_GIT},
                
                # Git Setup Phase
                *self._create_review_transitions(
                    source_state=StartTaskState.PREPARING_GIT,
                    review_state=StartTaskState.REVIEWING_GIT,
                    success_destination_state=StartTaskState.WORKSPACE_READY
                ),
            ]
    
            self.machine = Machine(model=self, states=states, transitions=transitions, initial=StartTaskState.FETCHING_REQUIREMENTS)
    
        @property
        def is_terminal(self) -> bool:
            return self.state == StartTaskState.WORKSPACE_READY
    ```

#### **Acceptance Criteria:**
*   The `StartTaskTool` class is correctly defined in `workflow.py` and inherits from `BaseWorkflowTool`.
*   The State Machine is configured with the correct states, transitions, and artifact map.

---
### **TASK: AL-37 (Definitive)**

#### **Title:**
Tools: Implement `start_task` Entry Point Logic

#### **Context:**
This creates the primary entry point logic for the `start_task` tool. It handles tool recovery/creation, reads the `task_provider` from the configuration, and dispatches the initial prompt to the AI.

#### **Implementation Details:**

1.  **`src/alfred_new/tools/start_task.py` (NEW FILE):**
    ```python
    # src/alfred_new/tools/start_task.py
    from src.alfred_new.models.schemas import ToolResponse
    from src.alfred_new.config.config_manager import config_manager
    from src.alfred_new.orchestration.orchestrator import orchestrator
    from src.alfred_new.orchestration.persona_loader import load_persona
    from src.alfred_new.core.workflow import StartTaskTool
    from src.alfred_new.state.recovery import ToolRecovery
    from src.alfred_new.state.manager import state_manager
    from src.alfred_new.core.prompter import prompter
    from src.alfred_new.lib.logger import get_logger, setup_task_logging

    logger = get_logger(__name__)

    async def start_task_impl(task_id: str) -> ToolResponse:
        """Implementation logic for the start_task tool."""
        setup_task_logging(task_id)

        # Standard tool recovery/creation boilerplate
        if task_id in orchestrator.active_tools:
            tool_instance = orchestrator.active_tools[task_id]
        else:
            tool_instance = ToolRecovery.recover_tool(task_id)
            if not tool_instance:
                tool_instance = StartTaskTool(task_id=task_id)
            
            orchestrator.active_tools[task_id] = tool_instance
        
        # Load config to determine the task provider
        config = config_manager.get_config()
        
        persona_config = load_persona(tool_instance.persona_name)
        
        # Add task_provider to context for the prompt
        additional_context = tool_instance.context_store.copy()
        additional_context['task_provider'] = config.task_provider

        next_prompt = prompter.generate_prompt(
            task_id=task_id, # We don't have a full Task object yet
            tool_name=tool_instance.tool_name,
            state=tool_instance.state,
            persona_config=persona_config,
            additional_context=additional_context
        )
        
        state_manager.save_tool_state(task_id, tool_instance)

        return ToolResponse(
            status="success",
            message=f"Initiated workspace setup for task '{task_id}'.",
            next_prompt=next_prompt
        )
    ```

#### **Acceptance Criteria:**
*   The `start_task_impl` function correctly recovers or creates a `StartTaskTool`.
*   It correctly reads the `task_provider` from the config.
*   It generates the initial prompt for the `FETCHING_REQUIREMENTS` state.

---
### **TASK: AL-38 (Definitive)**

#### **Title:**
Prompts: Create `start_task` Prompt Templates

#### **Context:**
This task creates the Jinja2 templates for each state of the `start_task` workflow, providing the AI with precise instructions for each step.

#### **Implementation Details:**

1.  **`src/alfred_new/templates/prompts/start_task/` (NEW DIRECTORY)**
2.  **Create `.md` files:**
    *   **`fetching_requirements.md`:**
        ```markdown
        # ROLE: {{ persona.name }}, {{ persona.title }}
        # STATE: fetching_requirements

        Your mission is to fetch the full details for task **`{{ task_id }}`**.
        The configured task provider is **`{{ additional_context.task_provider }}`**.

        ---
        ### **Directive**
        1.  Based on the provider, use the appropriate external tool to fetch the task details (e.g., `mcp__atlassian__getJiraIssue` for 'atlassian', or read from `.alfred/local_tasks/` for 'local').
        2.  Transform the fetched data into a `RequirementsArtifact`.

        ---
        ### **Required Action**
        Call `alfred.submit_work` with the populated `RequirementsArtifact`.
        ```
    *   **`reviewing_requirements.md`:** (Standard review prompt, presents the `RequirementsArtifact`)
    *   **`writing_task_file.md`:**
        ```markdown
        # ROLE: {{ persona.name }}, {{ persona.title }}
        # STATE: writing_task_file

        The requirements have been approved. You must now create the canonical Markdown task file.

        ---
        ### **Directive**
        1.  Take the approved `RequirementsArtifact` from the context.
        2.  Format its contents into our standard Markdown task format.
        3.  Save the content to a new file at `.alfred/tasks/{{ task_id }}.md`.

        ---
        ### **Required Action**
        Call `alfred.submit_work` with a `TaskFileCreationArtifact` to confirm completion.
        ```
    *   **`preparing_git.md`:**
        ```markdown
        # ROLE: {{ persona.name }}, {{ persona.title }}
        # STATE: preparing_git

        The task file has been created. Now, prepare the Git environment.

        ---
        ### **Directive**
        1.  Run `git status --porcelain` to check if the repository is clean.
        2.  Check if the branch `feature/{{ task_id }}` already exists.
        3.  If the repo is clean and the branch does not exist, create and check out the branch.
        4.  **If the repo is dirty or the branch exists, you MUST ask the human developer for instructions.** Do not proceed automatically.

        ---
        ### **Required Action**
        Call `alfred.submit_work` with a `GitSetupArtifact` detailing the status.
        ```
    *   **`reviewing_git.md`:** (Standard review prompt, presents the `GitSetupArtifact`)

#### **Acceptance Criteria:**
*   The new directory and all specified `.md` files are created with the correct content.

---
### **TASK: AL-39 (Definitive)**

#### **Title:**
System: Register `start_task` Tool

#### **Context:**
This final task integrates the new tool into the server and recovery system, making it live and callable.

#### **Implementation Details:**

1.  **`src/alfred_new/server.py` (MODIFY):**
    ```python
    # ... other imports ...
    from src.alfred_new.tools.start_task import start_task_impl

    # ... other tools ...
    
    @app.tool()
    async def start_task(task_id: str) -> ToolResponse:
        """
        Initiates the full workspace setup for a given task ID.
    
        This is the primary starting point for any new work. It handles:
        1.  Fetching task requirements from the configured provider (Jira, local, etc.).
        2.  Creating the canonical .md task file in the .alfred/tasks/ directory.
        3.  Preparing a clean git feature branch for development.
    
        Upon completion, the task is ready for the 'plan_task' command.
    
        Args:
            task_id: The unique identifier for the task to start (e.g., 'PROJ-123').
        """
        return await start_task_impl(task_id)
    ```

2.  **`src/alfred_new/state/recovery.py` (MODIFY):**
    ```python
    # ... other imports ...
    from src.alfred_new.core.workflow import StartTaskTool, PlanTaskTool

    TOOL_REGISTRY = {
        'plan_task': PlanTaskTool,
        # --- ADD NEW TOOL ---
        'start_task': StartTaskTool
    }
    # ...
    ```

#### **Acceptance Criteria:**
*   The `start_task` tool is exposed on the MCP server with a comprehensive docstring.
*   The `StartTaskTool` is registered for state recovery.
*   The server starts without errors.