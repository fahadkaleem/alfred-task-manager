### **TASK: AL-08**

#### **Title:**
Architectural Core: Implement Generic State-Advancing Tools

#### **Context:**
Our `plan_task` tool can now be initiated, but it's a one-way street. We need the mechanisms to handle the conversational back-and-forth of our internal State Machine. This task involves implementing the two generic, context-aware tools—`submit_work` and `provide_review`—that will drive all our workflow tools. These tools are the engine of our internal loops. They will read the active tool from the `Orchestrator`, trigger the appropriate event on that tool's State Machine, and use the `Prompter` to return the prompt for the new state.

#### **Implementation Details:**
1.  **Refactor the existing `submit_work` and `provide_review` tools.** Locate their current implementations (likely in `src/alfred/tools/task_tools.py` and `review_tools.py`). We will move their core logic into new, dedicated modules and adapt them to our new architecture.
2.  **Implement `submit_work_impl`.** This function will:
    a.  Look up the `active_tool` for the given `task_id` from the `orchestrator.active_tools` dictionary. If none is found, return an error.
    b.  Determine the correct SM trigger to call. By convention, this will be `f"submit_{current_state_name}"` (e.g., `submit_contextualize`). This makes the tool generic.
    c.  Call the trigger on the active tool's `machine` instance (e.g., `active_tool.machine.trigger('submit_contextualize')`).
    d.  Persist the submitted artifact to the scratchpad using the `ArtifactManager`.
    e.  Use the `prompter` to generate the prompt for the tool's *new* state.
    f.  Return the new prompt in the `ToolResponse`.
3.  **Implement `provide_review_impl`.** This function will have similar logic:
    a.  Look up the `active_tool`.
    b.  Determine the trigger based on the `is_approved` flag (`ai_approve` or `request_revision`).
    c.  Call the trigger on the active tool's `machine`.
    d.  Check if the new state is a terminal state (e.g., `VERIFIED`). If so, perform tool completion logic: update the master task status, remove the tool from the `orchestrator.active_tools`, and return a final handoff prompt.
    e.  If not a terminal state, use the `prompter` to generate the prompt for the new state and return it.
4.  **Update `server.py`:** Uncomment the `submit_work` and `provide_review` tool definitions and point them to their new implementation functions.

**Dev Notes:**
*   This is the most complex piece of our core architecture. The logic here must be generic and robust enough to drive *any* workflow tool we create.
*   Error handling is critical. What happens if a tool is not active for a task? What if an invalid trigger is called? The tool must return clear, helpful error messages.
*   The logic for handling the "tool completion" in `provide_review` is the key to our entire workflow. This is where a tool's lifecycle ends and the handoff to the next tool is initiated.

**Files to Modify/Create:**

1.  **`src/alfred/tools/submit_work.py` (NEW FILE):** (Will contain `submit_work_impl` function)
2.  **`src/alfred/tools/provide_review.py` (NEW FILE):** (Will contain `provide_review_impl` function)
3.  **`src/alfred/core/workflow.py` (MODIFY):** Add a `is_terminal` property or method to the `BaseWorkflowTool` to easily check if the SM is in its final state.
4.  **`src/alfred/server.py` (MODIFY):** Uncomment the tools and update their `import` paths.

#### **Acceptance Criteria:**
*   Calling `submit_work` correctly transitions the active tool's SM from a `_working` state to a `_review` state.
*   Calling `provide_review(is_approved=False)` correctly transitions the SM from a `_review` state back to a `_working` state.
*   Calling `provide_review(is_approved=True)` correctly transitions the SM from a `_review` state to the next `_working` state (or to the `VERIFIED` state).
*   When a tool's SM transitions to `VERIFIED`, the tool is removed from `orchestrator.active_tools`, the main `Task` status is updated, and a handoff prompt is returned.
*   The tools return appropriate error messages if no active tool is found for a given `task_id`.

#### **AC Verification:**
*   This requires an integration test that chains tool calls together:
    1.  Call `plan_task`.
    2.  Assert the active tool is `PlanTaskTool` and the state is `CONTEXTUALIZE`.
    3.  Call `submit_work` with a context artifact.
    4.  Assert the active tool's state is now `REVIEW_CONTEXT`.
    5.  Call `provide_review(is_approved=True)`.
    6.  Assert the active tool's state is now `STRATEGIZE`.
    7.  Repeat this process until the tool completes and is removed from the active tools list.

#### **Unit Tests:**
*   **`tests/tools/test_submit_work.py`:** Test success path, and error path (no active tool).
*   **`tests/tools/test_provide_review.py`:** Test approval, rejection, and final completion/handoff paths.