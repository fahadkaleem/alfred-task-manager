### **TASK: AL-13**

#### **Title:**
Core Engine: Implement `provide_review` and Tool Completion Logic

#### **Context:**
Our system can now initiate the `plan_task` tool and accept work via `submit_work`. However, it lacks the critical mechanism to approve that work and complete the tool's lifecycle. This task is to implement the full logic for the `provide_review` tool. This tool is the second half of our conversational engine. It processes approvals and rejections, drives the internal State Machine, and—most importantly—handles the "handoff" procedure when a tool's work is fully verified. Completing this will give us a fully functional, end-to-end workflow for a single tool.

#### **CRITICAL: REUSE EXISTING COMPONENTS**
This implementation must integrate seamlessly with the `Orchestrator`, `Task` and `TaskStatus` models, `Prompter`, and `BaseWorkflowTool` as they exist in the current codebase.

#### **Implementation Details:**
1.  **Locate the `provide_review.py` module.** The work will be done in the existing file `src/alfred/tools/provide_review.py`.
2.  **Replace the stub implementation.** The current code is a placeholder. It will be replaced with the complete logic that handles both mid-workflow reviews and final tool completion.
3.  **Implement the core logic for `provide_review_impl`:**
    a.  Look up the `active_tool` for the given `task_id` from `orchestrator.active_tools`.
    b.  Determine the correct State Machine trigger (`ai_approve` or `request_revision`) and apply it.
    c.  **Implement the Terminal State Check:** After the state transition, check if `active_tool.is_terminal` is `True`.
    d.  **If Terminal (Tool Complete):**
        i.  Update the master `Task` status. For the `plan_task` tool, the successful completion status is `TaskStatus.READY_FOR_DEVELOPMENT`. Use the `update_task_status` utility.
        ii. Remove the completed tool instance from `orchestrator.active_tools` to clean up the session.
        iii. Generate a final **handoff prompt** that explicitly tells the user the next command to run.
    e.  **If Not Terminal:**
        i.  Generate the next prompt for the new state using the `Prompter`, passing in `feedback_notes` as `additional_context` if a revision was requested.

**Dev Notes:**
*   This is the lynchpin of our entire tool-based architecture. The "Terminal State Check" is where one tool's responsibility ends and the system prepares for the next.
*   The `is_terminal` property in `BaseWorkflowTool` is critical. We must ensure it correctly identifies the `VERIFIED` state as the end of a tool's lifecycle.

**Files to Modify/Create:**

1.  **`src/alfred/tools/provide_review.py` (REPLACE):**
    ```python
    # src/alfred/tools/provide_review.py
    import json
    from src.alfred.models.schemas import ToolResponse, Task, TaskStatus
    from src.alfred.orchestration.orchestrator import orchestrator
    from src.alfred.lib.task_utils import load_task, update_task_status
    from src.alfred.core.prompter import prompter
    from src.alfred.lib.persona_loader import load_persona
    from src.alfred.lib.logger import get_logger

    logger = get_logger(__name__)

    def provide_review_impl(task_id: str, is_approved: bool, feedback_notes: str = "") -> ToolResponse:
        """
        Processes review feedback, advancing the active tool's State Machine.
        Handles both mid-workflow reviews and final tool completion.
        """
        if task_id not in orchestrator.active_tools:
            return ToolResponse(status="error", message=f"No active tool found for task '{task_id}'.")

        active_tool = orchestrator.active_tools[task_id]
        task = load_task(task_id)
        if not task:
            return ToolResponse(status="error", message=f"Task '{task_id}' not found.")

        # Determine the trigger and advance the state machine
        trigger = "ai_approve" if is_approved else "request_revision"
        if not hasattr(active_tool, trigger):
            return ToolResponse(status="error", message=f"Invalid action: cannot trigger '{trigger}' from state '{active_tool.state}'.")
        
        getattr(active_tool, trigger)()
        logger.info(f"Task {task_id}: State transitioned via trigger '{trigger}' to '{active_tool.state}'.")

        # Check if the new state is the tool's terminal state
        if active_tool.is_terminal:
            # --- TOOL COMPLETION LOGIC ---
            # This logic must be extensible for different tools in the future.
            # For now, we hardcode the outcome for plan_task.
            final_task_status = TaskStatus.READY_FOR_DEVELOPMENT
            handoff_message = (
                f"Planning for task {task_id} is complete and verified. "
                f"The task is now '{final_task_status.value}'.\n\n"
                f"To begin implementation, run `alfred.implement_task(task_id='{task_id}')`."
            )
            
            update_task_status(task_id, final_task_status)
            del orchestrator.active_tools[task_id]
            logger.info(f"Tool '{active_tool.tool_name}' for task {task_id} completed. Task status updated to '{final_task_status.value}'.")

            return ToolResponse(
                status="success",
                message=f"Tool '{active_tool.tool_name}' completed successfully.",
                next_prompt=handoff_message
            )
        else:
            # --- MID-WORKFLOW REVIEW LOGIC ---
            try:
                persona_config = load_persona(active_tool.persona_name)
            except FileNotFoundError as e:
                return ToolResponse(status="error", message=str(e))
            
            additional_context = {"feedback_notes": feedback_notes} if not is_approved and feedback_notes else None
            
            next_prompt = prompter.generate_prompt(
                task=task,
                tool_name=active_tool.tool_name,
                state=active_tool.state,
                persona_config=persona_config,
                additional_context=additional_context
            )
            
            message = "Review approved. Proceeding to next step." if is_approved else "Revision requested."
            return ToolResponse(status="success", message=message, next_prompt=next_prompt)
    ```

#### **Acceptance Criteria:**
*   The `provide_review` tool correctly transitions the State Machine for both approval and rejection scenarios.
*   When a rejection (`is_approved=False`) is processed, the `feedback_notes` are correctly included in the `additional_context` passed to the `Prompter`.
*   When the active tool's State Machine reaches its terminal `VERIFIED` state, the `provide_review` tool correctly identifies this.
*   Upon reaching the terminal state, the master `Task`'s status is updated to `READY_FOR_DEVELOPMENT`.
*   Upon reaching the terminal state, the tool instance is removed from the `orchestrator.active_tools` dictionary.
*   Upon reaching the terminal state, a final handoff prompt is returned to the user.

#### **AC Verification (using "Simulated Reality" harness):**
*   Create a single, comprehensive integration test that simulates the entire `plan_task` lifecycle from start to finish.
*   The test will:
    1.  Call `plan_task` to initiate the tool.
    2.  Call `submit_work` and `provide_review(is_approved=True)` repeatedly to advance through all the states (`CONTEXTUALIZE`, `STRATEGIZE`, `DESIGN`, `GENERATE_SLOTS`).
    3.  On the final `provide_review` call (the one that moves the SM to `VERIFIED`), assert the following:
        *   The returned `ToolResponse` contains the correct handoff message.
        *   The `task.json` file on disk shows `"task_status": "ready_for_development"`.
        *   The `orchestrator.active_tools` dictionary is now empty for that `task_id`.

#### **Unit Tests:**
*   Create `tests/tools/test_provide_review.py`.
*   Write the comprehensive integration test `test_full_planning_lifecycle_completes_successfully` that follows the AC Verification steps.
*   Write a separate test `test_review_rejection_reverts_state` that calls `provide_review(is_approved=False)` and confirms the SM transitions back to the previous working state.
